{
  "version": 3,
  "sources": ["../../three-bvh-csg/src/core/utils/hashUtils.js", "../../three-bvh-csg/src/core/utils/geometryUtils.js", "../../three-bvh-csg/src/core/utils/halfEdgeUtils.js", "../../three-bvh-csg/src/core/utils/RaySet.js", "../../three-bvh-csg/src/core/utils/computeDisjointEdges.js", "../../three-bvh-csg/src/core/HalfEdgeMap.js", "../../three-bvh-csg/src/core/Brush.js", "../../three-bvh-csg/src/core/utils/triangleUtils.js", "../../three-bvh-csg/src/core/TriangleSplitter.js", "../../three-bvh-csg/src/core/TypeBackedArray.js", "../../three-bvh-csg/src/core/TypedAttributeData.js", "../../three-bvh-csg/src/core/IntersectionMap.js", "../../three-bvh-csg/src/core/constants.js", "../../three-bvh-csg/src/core/operations/operationsUtils.js", "../../three-bvh-csg/src/core/debug/OperationDebugData.js", "../../three-bvh-csg/src/core/operations/operations.js", "../../three-bvh-csg/src/core/Evaluator.js", "../../three-bvh-csg/src/core/operations/Operation.js", "../../three-bvh-csg/src/core/operations/OperationGroup.js", "../../three-bvh-csg/src/materials/shaderUtils.js", "../../three-bvh-csg/src/materials/GridMaterial.js", "../../three-bvh-csg/src/core/debug/debugUtils.js", "../../three-bvh-csg/src/objects/TriangleSetHelper.js", "../../three-bvh-csg/src/objects/EdgesHelper.js", "../../three-bvh-csg/src/objects/PointsHelper.js", "../../three-bvh-csg/src/objects/HalfEdgeHelper.js", "../../three-bvh-csg/src/utils/computeMeshVolume.js"],
  "sourcesContent": ["const HASH_WIDTH = 1e-6;\r\nconst HASH_HALF_WIDTH = HASH_WIDTH * 0.5;\r\nconst HASH_MULTIPLIER = Math.pow( 10, - Math.log10( HASH_WIDTH ) );\r\nconst HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;\r\nexport function hashNumber( v ) {\r\n\r\n\treturn ~ ~ ( v * HASH_MULTIPLIER + HASH_ADDITION );\r\n\r\n}\r\n\r\nexport function hashVertex2( v ) {\r\n\r\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) }`;\r\n\r\n}\r\n\r\nexport function hashVertex3( v ) {\r\n\r\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) }`;\r\n\r\n}\r\n\r\nexport function hashVertex4( v ) {\r\n\r\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) },${ hashNumber( v.w ) }`;\r\n\r\n}\r\n\r\nexport function hashRay( r ) {\r\n\r\n\treturn `${ hashVertex3( r.origin ) }-${ hashVertex3( r.direction ) }`;\r\n\r\n}\r\n\r\nexport function toNormalizedRay( v0, v1, target ) {\r\n\r\n\t// get a normalized direction\r\n\ttarget\r\n\t\t.direction\r\n\t\t.subVectors( v1, v0 )\r\n\t\t.normalize();\r\n\r\n\t// project the origin onto the perpendicular plane that\r\n\t// passes through 0, 0, 0\r\n\tconst scalar = v0.dot( target.direction );\r\n\ttarget.\r\n\t\torigin\r\n\t\t.copy( v0 )\r\n\t\t.addScaledVector( target.direction, - scalar );\r\n\r\n\treturn target;\r\n\r\n}\r\n", "import { BufferAttribute } from 'three';\r\n\r\nexport function areSharedArrayBuffersSupported() {\r\n\r\n\treturn typeof SharedArrayBuffer !== 'undefined';\r\n\r\n}\r\n\r\nexport function convertToSharedArrayBuffer( array ) {\r\n\r\n\tif ( array.buffer instanceof SharedArrayBuffer ) {\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\tconst cons = array.constructor;\r\n\tconst buffer = array.buffer;\r\n\tconst sharedBuffer = new SharedArrayBuffer( buffer.byteLength );\r\n\r\n\tconst uintArray = new Uint8Array( buffer );\r\n\tconst sharedUintArray = new Uint8Array( sharedBuffer );\r\n\tsharedUintArray.set( uintArray, 0 );\r\n\r\n\treturn new cons( sharedBuffer );\r\n\r\n}\r\n\r\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\r\n\r\n\tif ( vertexCount > 65535 ) {\r\n\r\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t} else {\r\n\r\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function getVertexCount( geo ) {\r\n\r\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\r\n\r\n}\r\n\r\nexport function getTriCount( geo ) {\r\n\r\n\treturn getVertexCount( geo ) / 3;\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\n\r\nconst DEGENERATE_EPSILON = 1e-8;\r\nconst _tempVec = new Vector3();\r\n\r\nexport function toTriIndex( v ) {\r\n\r\n\treturn ~ ~ ( v / 3 );\r\n\r\n}\r\n\r\nexport function toEdgeIndex( v ) {\r\n\r\n\treturn v % 3;\r\n\r\n}\r\n\r\nexport function sortEdgeFunc( a, b ) {\r\n\r\n\treturn a.start - b.start;\r\n\r\n}\r\n\r\nexport function getProjectedDistance( ray, vec ) {\r\n\r\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\r\n\r\n}\r\n\r\nexport function hasOverlaps( arr ) {\r\n\r\n\tarr = [ ...arr ].sort( sortEdgeFunc );\r\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\r\n\r\n\t\tconst info0 = arr[ i ];\r\n\t\tconst info1 = arr[ i + 1 ];\r\n\r\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nexport function getEdgeSetLength( arr ) {\r\n\r\n\tlet tot = 0;\r\n\tarr.forEach( ( { start, end } ) => tot += end - start );\r\n\treturn tot;\r\n\r\n}\r\n\r\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\r\n\r\n\tforward.sort( sortEdgeFunc );\r\n\treverse.sort( sortEdgeFunc );\r\n\r\n\tfor ( let i = 0; i < forward.length; i ++ ) {\r\n\r\n\t\tconst e0 = forward[ i ];\r\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\r\n\r\n\t\t\tconst e1 = reverse[ o ];\r\n\t\t\tif ( e1.start > e0.end ) {\r\n\r\n\t\t\t\t// e2 is completely after e1\r\n\t\t\t\t// break;\r\n\r\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\r\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\r\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\r\n\t\t\t\t// triangles before this.\r\n\r\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\r\n\r\n\t\t\t\t// e1 is completely before e2\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\r\n\r\n\t\t\t\t// e1 is larger than and e2 is completely within e1\r\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\r\n\r\n\t\t\t\t\tforward.splice( i + 1, 0, {\r\n\t\t\t\t\t\tstart: e1.end,\r\n\t\t\t\t\t\tend: e0.end,\r\n\t\t\t\t\t\tindex: e0.index,\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\te0.end = e1.start;\r\n\r\n\t\t\t\te1.start = 0;\r\n\t\t\t\te1.end = 0;\r\n\r\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\r\n\r\n\t\t\t\t// e2 is larger than and e1 is completely within e2\r\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\r\n\r\n\t\t\t\t\treverse.splice( o + 1, 0, {\r\n\t\t\t\t\t\tstart: e0.end,\r\n\t\t\t\t\t\tend: e1.end,\r\n\t\t\t\t\t\tindex: e1.index,\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\te1.end = e0.start;\r\n\r\n\t\t\t\te0.start = 0;\r\n\t\t\t\te0.end = 0;\r\n\r\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\r\n\r\n\t\t\t\t// e1 overlaps e2 at the beginning\r\n\t\t\t\tconst tmp = e0.end;\r\n\t\t\t\te0.end = e1.start;\r\n\t\t\t\te1.start = tmp;\r\n\r\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\r\n\r\n\t\t\t\t// e1 overlaps e2 at the end\r\n\t\t\t\tconst tmp = e1.end;\r\n\t\t\t\te1.end = e0.start;\r\n\t\t\t\te0.start = tmp;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Add the connectivity information\r\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\r\n\r\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\r\n\r\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdisjointConnectivityMap\r\n\t\t\t\t.get( e0.index )\r\n\t\t\t\t.push( e1.index );\r\n\r\n\t\t\tdisjointConnectivityMap\r\n\t\t\t\t.get( e1.index )\r\n\t\t\t\t.push( e0.index );\r\n\r\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\r\n\r\n\t\t\t\treverse.splice( o, 1 );\r\n\t\t\t\to --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\r\n\r\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\r\n\t\t\t\t// so we can work on the next one\r\n\t\t\t\tforward.splice( i, 1 );\r\n\t\t\t\ti --;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcleanUpEdgeSet( forward );\r\n\tcleanUpEdgeSet( reverse );\r\n\r\n\tfunction cleanUpEdgeSet( arr ) {\r\n\r\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\r\n\r\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\r\n\r\n\t\t\t\tarr.splice( i, 1 );\r\n\t\t\t\ti --;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction areDistancesDegenerate( start, end ) {\r\n\r\n\t\treturn Math.abs( end - start ) < eps;\r\n\r\n\t}\r\n\r\n\tfunction isEdgeDegenerate( e ) {\r\n\r\n\t\treturn Math.abs( e.end - e.start ) < eps;\r\n\r\n\t}\r\n\r\n}\r\n", "const DIST_EPSILON = 1e-5;\r\nconst ANGLE_EPSILON = 1e-4;\r\n\r\nexport class RaySet {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._rays = [];\r\n\r\n\t}\r\n\r\n\taddRay( ray ) {\r\n\r\n\t\tthis._rays.push( ray );\r\n\r\n\t}\r\n\r\n\tfindClosestRay( ray ) {\r\n\r\n\t\tconst rays = this._rays;\r\n\t\tconst inv = ray.clone();\r\n\t\tinv.direction.multiplyScalar( - 1 );\r\n\r\n\t\tlet bestScore = Infinity;\r\n\t\tlet bestRay = null;\r\n\t\tfor ( let i = 0, l = rays.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst r = rays[ i ];\r\n\t\t\tif ( skipRay( r, ray ) && skipRay( r, inv ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst rayScore = scoreRays( r, ray );\r\n\t\t\tconst invScore = scoreRays( r, inv );\r\n\t\t\tconst score = Math.min( rayScore, invScore );\r\n\t\t\tif ( score < bestScore ) {\r\n\r\n\t\t\t\tbestScore = score;\r\n\t\t\t\tbestRay = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bestRay;\r\n\r\n\t\tfunction skipRay( r0, r1 ) {\r\n\r\n\t\t\tconst distOutOfThreshold = r0.origin.distanceTo( r1.origin ) > DIST_EPSILON;\r\n\t\t\tconst angleOutOfThreshold = r0.direction.angleTo( r1.direction ) > ANGLE_EPSILON;\r\n\t\t\treturn angleOutOfThreshold || distOutOfThreshold;\r\n\r\n\t\t}\r\n\r\n\t\tfunction scoreRays( r0, r1 ) {\r\n\r\n\t\t\tconst originDistance = r0.origin.distanceTo( r1.origin );\r\n\t\t\tconst angleDistance = r0.direction.angleTo( r1.direction );\r\n\t\t\treturn originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3, Ray } from 'three';\r\nimport { toEdgeIndex, toTriIndex, matchEdges, getProjectedDistance } from './halfEdgeUtils.js';\r\nimport { toNormalizedRay } from './hashUtils.js';\r\nimport { RaySet } from './RaySet.js';\r\n\r\nconst _v0 = new Vector3();\r\nconst _v1 = new Vector3();\r\nconst _ray = new Ray();\r\n\r\nexport function computeDisjointEdges(\r\n\tgeometry,\r\n\tunmatchedSet,\r\n\teps,\r\n) {\r\n\r\n\tconst attributes = geometry.attributes;\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = attributes.position;\r\n\r\n\tconst disjointConnectivityMap = new Map();\r\n\tconst fragmentMap = new Map();\r\n\tconst edges = Array.from( unmatchedSet );\r\n\tconst rays = new RaySet();\r\n\r\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\r\n\r\n\t\t// get the triangle edge\r\n\t\tconst index = edges[ i ];\r\n\t\tconst triIndex = toTriIndex( index );\r\n\t\tconst edgeIndex = toEdgeIndex( index );\r\n\r\n\t\tlet i0 = 3 * triIndex + edgeIndex;\r\n\t\tlet i1 = 3 * triIndex + ( edgeIndex + 1 ) % 3;\r\n\t\tif ( indexAttr ) {\r\n\r\n\t\t\ti0 = indexAttr.getX( i0 );\r\n\t\t\ti1 = indexAttr.getX( i1 );\r\n\r\n\t\t}\r\n\r\n\t\t_v0.fromBufferAttribute( posAttr, i0 );\r\n\t\t_v1.fromBufferAttribute( posAttr, i1 );\r\n\r\n\t\t// get the ray corresponding to the edge\r\n\t\ttoNormalizedRay( _v0, _v1, _ray );\r\n\r\n\t\t// find the shared ray with other edges\r\n\t\tlet info;\r\n\t\tlet commonRay = rays.findClosestRay( _ray );\r\n\t\tif ( commonRay === null ) {\r\n\r\n\t\t\tcommonRay = _ray.clone();\r\n\t\t\trays.addRay( commonRay );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! fragmentMap.has( commonRay ) ) {\r\n\r\n\t\t\tfragmentMap.set( commonRay, {\r\n\r\n\t\t\t\tforward: [],\r\n\t\t\t\treverse: [],\r\n\t\t\t\tray: commonRay,\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tinfo = fragmentMap.get( commonRay );\r\n\r\n\t\t// store the stride of edge endpoints along the ray\r\n\t\tlet start = getProjectedDistance( commonRay, _v0 );\r\n\t\tlet end = getProjectedDistance( commonRay, _v1 );\r\n\t\tif ( start > end ) {\r\n\r\n\t\t\t[ start, end ] = [ end, start ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( _ray.direction.dot( commonRay.direction ) < 0 ) {\r\n\r\n\t\t\tinfo.reverse.push( { start, end, index } );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinfo.forward.push( { start, end, index } );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// match the found sibling edges\r\n\tfragmentMap.forEach( ( { forward, reverse }, ray ) => {\r\n\r\n\t\tmatchEdges( forward, reverse, disjointConnectivityMap, eps );\r\n\r\n\t\tif ( forward.length === 0 && reverse.length === 0 ) {\r\n\r\n\t\t\tfragmentMap.delete( ray );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn {\r\n\t\tdisjointConnectivityMap,\r\n\t\tfragmentMap,\r\n\t};\r\n\r\n}\r\n\r\n", "import { Vector2, Vector3, Vector4 } from 'three';\r\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\r\nimport { getTriCount } from './utils/geometryUtils.js';\r\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\r\n\r\nconst _vec2 = new Vector2();\r\nconst _vec3 = new Vector3();\r\nconst _vec4 = new Vector4();\r\nconst _hashes = [ '', '', '' ];\r\n\r\nexport class HalfEdgeMap {\r\n\r\n\tconstructor( geometry = null ) {\r\n\r\n\t\t// result data\r\n\t\tthis.data = null;\r\n\t\tthis.disjointConnections = null;\r\n\t\tthis.unmatchedDisjointEdges = null;\r\n\t\tthis.unmatchedEdges = - 1;\r\n\t\tthis.matchedEdges = - 1;\r\n\r\n\t\t// options\r\n\t\tthis.useDrawRange = true;\r\n\t\tthis.useAllAttributes = false;\r\n\t\tthis.matchDisjointEdges = false;\r\n\t\tthis.degenerateEpsilon = 1e-8;\r\n\r\n\t\tif ( geometry ) {\r\n\r\n\t\t\tthis.updateFrom( geometry );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\r\n\r\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\r\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\r\n\r\n\t}\r\n\r\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\r\n\r\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\r\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\r\n\r\n\t}\r\n\r\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\r\n\r\n\t\tconst index = triIndex * 3 + edgeIndex;\r\n\t\tconst arr = this.disjointConnections.get( index );\r\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\r\n\r\n\t}\r\n\r\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\r\n\r\n\t\tconst index = triIndex * 3 + edgeIndex;\r\n\t\tconst arr = this.disjointConnections.get( index );\r\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\r\n\r\n\t}\r\n\r\n\tisFullyConnected() {\r\n\r\n\t\treturn this.unmatchedEdges === 0;\r\n\r\n\t}\r\n\r\n\tupdateFrom( geometry ) {\r\n\r\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\r\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\r\n\r\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\r\n\t\tconst map = new Map();\r\n\r\n\t\t// attributes\r\n\t\tconst { attributes } = geometry;\r\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\r\n\t\tconst indexAttr = geometry.index;\r\n\t\tconst posAttr = attributes.position;\r\n\r\n\t\t// get the potential number of triangles\r\n\t\tlet triCount = getTriCount( geometry );\r\n\t\tconst maxTriCount = triCount;\r\n\r\n\t\t// get the real number of triangles from the based on the draw range\r\n\t\tlet offset = 0;\r\n\t\tif ( useDrawRange ) {\r\n\r\n\t\t\toffset = geometry.drawRange.start;\r\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\r\n\r\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// initialize the connectivity buffer - 1 means no connectivity\r\n\t\tlet data = this.data;\r\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\r\n\r\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\r\n\r\n\t\t}\r\n\r\n\t\tdata.fill( - 1 );\r\n\r\n\t\t// iterate over all triangles\r\n\t\tlet matchedEdges = 0;\r\n\t\tlet unmatchedSet = new Set();\r\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\r\n\r\n\t\t\tconst i3 = i;\r\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\tlet i0 = i3 + e;\r\n\t\t\t\tif ( indexAttr ) {\r\n\r\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\r\n\t\t\t\tconst vh0 = _hashes[ e ];\r\n\t\t\t\tconst vh1 = _hashes[ nextE ];\r\n\r\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\r\n\t\t\t\tif ( map.has( reverseHash ) ) {\r\n\r\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\r\n\t\t\t\t\tconst index = i3 + e;\r\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\r\n\t\t\t\t\tdata[ index ] = otherIndex;\r\n\t\t\t\t\tdata[ otherIndex ] = index;\r\n\t\t\t\t\tmap.delete( reverseHash );\r\n\t\t\t\t\tmatchedEdges += 2;\r\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\r\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\r\n\t\t\t\t\t// edgeIndex = i0 % 3;\r\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\r\n\t\t\t\t\tconst index = i3 + e;\r\n\t\t\t\t\tmap.set( hash, index );\r\n\t\t\t\t\tunmatchedSet.add( index );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( matchDisjointEdges ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tfragmentMap,\r\n\t\t\t\tdisjointConnectivityMap,\r\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\r\n\r\n\t\t\tunmatchedSet.clear();\r\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\r\n\r\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\r\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\r\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\r\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\r\n\r\n\t\t}\r\n\r\n\t\tthis.matchedEdges = matchedEdges;\r\n\t\tthis.unmatchedEdges = unmatchedSet.size;\r\n\t\tthis.data = data;\r\n\r\n\t\tfunction hashPositionAttribute( i ) {\r\n\r\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\r\n\t\t\treturn hashVertex3( _vec3 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction hashAllAttributes( i ) {\r\n\r\n\t\t\tlet result = '';\r\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\r\n\r\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\r\n\t\t\t\tlet str;\r\n\t\t\t\tswitch ( attr.itemSize ) {\r\n\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( result !== '' ) {\r\n\r\n\t\t\t\t\tresult += '|';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult += str;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Mesh, Matrix4 } from 'three';\r\nimport { MeshBVH } from 'three-mesh-bvh';\r\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\r\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\r\n\r\nexport class Brush extends Mesh {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isBrush = true;\r\n\t\tthis._previousMatrix = new Matrix4();\r\n\t\tthis._previousMatrix.elements.fill( 0 );\r\n\r\n\t}\r\n\r\n\tmarkUpdated() {\r\n\r\n\t\tthis._previousMatrix.copy( this.matrix );\r\n\r\n\t}\r\n\r\n\tisDirty() {\r\n\r\n\t\tconst { matrix, _previousMatrix } = this;\r\n\t\tconst el1 = matrix.elements;\r\n\t\tconst el2 = _previousMatrix.elements;\r\n\t\tfor ( let i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tprepareGeometry() {\r\n\r\n\t\t// generate shared array buffers\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\r\n\t\tif ( useSharedArrayBuffer ) {\r\n\r\n\t\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\t\tconst attribute = attributes[ key ];\r\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate bounds tree\r\n\t\tif ( ! geometry.boundsTree ) {\r\n\r\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\r\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\r\n\r\n\t\t}\r\n\r\n\t\t// generate half edges\r\n\t\tif ( ! geometry.halfEdges ) {\r\n\r\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\r\n\r\n\t\t}\r\n\r\n\t\t// save group indices for materials\r\n\t\tif ( ! geometry.groupIndices ) {\r\n\r\n\t\t\tconst triCount = getTriCount( geometry );\r\n\t\t\tconst array = new Uint16Array( triCount );\r\n\t\t\tconst groups = geometry.groups;\r\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst { start, count } = groups[ i ];\r\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\r\n\r\n\t\t\t\t\tarray[ g ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.groupIndices = array;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdisposeCacheData() {\r\n\r\n\t\tconst { geometry } = this;\r\n\t\tgeometry.halfEdges = null;\r\n\t\tgeometry.boundsTree = null;\r\n\t\tgeometry.groupIndices = null;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\n\r\nconst EPSILON = 1e-14;\r\nconst _AB = new Vector3();\r\nconst _AC = new Vector3();\r\nconst _CB = new Vector3();\r\n\r\nexport function isTriDegenerate( tri, eps = EPSILON ) {\r\n\r\n\t// compute angles to determine whether they're degenerate\r\n\t_AB.subVectors( tri.b, tri.a );\r\n\t_AC.subVectors( tri.c, tri.a );\r\n\t_CB.subVectors( tri.b, tri.c );\r\n\r\n\tconst angle1 = _AB.angleTo( _AC );\t\t\t\t// AB v AC\r\n\tconst angle2 = _AB.angleTo( _CB );\t\t\t\t// AB v BC\r\n\tconst angle3 = Math.PI - angle1 - angle2;\t\t// 180deg - angle1 - angle2\r\n\r\n\treturn Math.abs( angle1 ) < eps ||\r\n\t\tMath.abs( angle2 ) < eps ||\r\n\t\tMath.abs( angle3 ) < eps ||\r\n\t\ttri.a.distanceToSquared( tri.b ) < eps ||\r\n\t\ttri.a.distanceToSquared( tri.c ) < eps ||\r\n\t\ttri.b.distanceToSquared( tri.c ) < eps;\r\n\r\n}\r\n", "import { Triangle, Line3, Vector3, Plane } from 'three';\r\nimport { ExtendedTriangle } from 'three-mesh-bvh';\r\nimport { isTriDegenerate } from './utils/triangleUtils.js';\r\n\r\n// NOTE: these epsilons likely should all be the same since they're used to measure the\r\n// distance from a point to a plane which needs to be done consistently\r\nconst EPSILON = 1e-10;\r\nconst COPLANAR_EPSILON = 1e-10;\r\nconst PARALLEL_EPSILON = 1e-10;\r\nconst _edge = new Line3();\r\nconst _foundEdge = new Line3();\r\nconst _vec = new Vector3();\r\nconst _triangleNormal = new Vector3();\r\nconst _planeNormal = new Vector3();\r\nconst _plane = new Plane();\r\nconst _splittingTriangle = new ExtendedTriangle();\r\n\r\n// A pool of triangles to avoid unnecessary triangle creation\r\nclass TrianglePool {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._pool = [];\r\n\t\tthis._index = 0;\r\n\r\n\t}\r\n\r\n\tgetTriangle() {\r\n\r\n\t\tif ( this._index >= this._pool.length ) {\r\n\r\n\t\t\tthis._pool.push( new Triangle() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this._pool[ this._index ++ ];\r\n\r\n\t}\r\n\r\n\tclear() {\r\n\r\n\t\tthis._index = 0;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._pool.length = 0;\r\n\t\tthis._index = 0;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Utility class for splitting triangles\r\nexport class TriangleSplitter {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.trianglePool = new TrianglePool();\r\n\t\tthis.triangles = [];\r\n\t\tthis.normal = new Vector3();\r\n\t\tthis.coplanarTriangleUsed = false;\r\n\r\n\t}\r\n\r\n\t// initialize the class with a triangle\r\n\tinitialize( tri ) {\r\n\r\n\t\tthis.reset();\r\n\r\n\t\tconst { triangles, trianglePool, normal } = this;\r\n\t\tif ( Array.isArray( tri ) ) {\r\n\r\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst t = tri[ i ];\r\n\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\tt.getNormal( normal );\r\n\r\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\r\n\t\t\t\tpoolTri.copy( t );\r\n\t\t\t\ttriangles.push( poolTri );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttri.getNormal( normal );\r\n\r\n\t\t\tconst poolTri = trianglePool.getTriangle();\r\n\t\t\tpoolTri.copy( tri );\r\n\t\t\ttriangles.push( poolTri );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\r\n\t// coplanar it will attempt to split by the triangle edge planes\r\n\tsplitByTriangle( triangle ) {\r\n\r\n\t\tconst { normal, triangles } = this;\r\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\r\n\r\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\r\n\r\n\t\t\tthis.coplanarTriangleUsed = true;\r\n\r\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst t = triangles[ i ];\r\n\t\t\t\tt.coplanarCount = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if the triangle is coplanar then split by the edge planes\r\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\r\n\r\n\t\t\t\tconst v0 = arr[ i ];\r\n\t\t\t\tconst v1 = arr[ nexti ];\r\n\r\n\t\t\t\t// plane positive direction is toward triangle center\r\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\r\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\r\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\r\n\r\n\t\t\t\tthis.splitByPlane( _plane, triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// otherwise split by the triangle plane\r\n\t\t\ttriangle.getPlane( _plane );\r\n\t\t\tthis.splitByPlane( _plane, triangle );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\r\n\t// intersect the triangle before splitting the plane\r\n\tsplitByPlane( plane, clippingTriangle ) {\r\n\r\n\t\tconst { triangles, trianglePool } = this;\r\n\r\n\t\t// init our triangle to check for intersection\r\n\t\t_splittingTriangle.copy( clippingTriangle );\r\n\t\t_splittingTriangle.needsUpdate = true;\r\n\r\n\t\t// try to split every triangle in the class\r\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst tri = triangles[ i ];\r\n\r\n\t\t\t// skip the triangle if we don't intersect with it\r\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst { a, b, c } = tri;\r\n\t\t\tlet intersects = 0;\r\n\t\t\tlet vertexSplitEnd = - 1;\r\n\t\t\tlet coplanarEdge = false;\r\n\t\t\tlet posSideVerts = [];\r\n\t\t\tlet negSideVerts = [];\r\n\t\t\tconst arr = [ a, b, c ];\r\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t\t// get the triangle edge\r\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\r\n\t\t\t\t_edge.start.copy( arr[ t ] );\r\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\r\n\r\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\r\n\t\t\t\t// so we can use that information to determine whether to split later.\r\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\r\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\r\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\tcoplanarEdge = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( startDist > 0 ) {\r\n\r\n\t\t\t\t\tposSideVerts.push( t );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnegSideVerts.push( t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\r\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\r\n\t\t\t\t// return it as an intersection (see issue #28)\r\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\r\n\t\t\t\t// point intersection here.\r\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\r\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\t_vec.copy( _edge.end );\r\n\t\t\t\t\tdidIntersect = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\r\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\r\n\r\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\r\n\t\t\t\t\t// have to split down the middle\r\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\r\n\r\n\t\t\t\t\t\tvertexSplitEnd = t;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// track the split edge\r\n\t\t\t\t\tif ( intersects === 0 ) {\r\n\r\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tintersects ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skip splitting if:\r\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\r\n\t\t\t// - the plane does not intersect on 2 points\r\n\t\t\t// - the intersection edge is too small\r\n\t\t\t// - we're not along a coplanar edge\r\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\r\n\r\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\r\n\r\n\t\t\t\t\t// we're splitting along a vertex\r\n\t\t\t\t\tlet otherVert1 = 0;\r\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\r\n\r\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\r\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\r\n\r\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\r\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\r\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\r\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\r\n\r\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.push( nextTri );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\r\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\r\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t// finish off the adjusted triangle\r\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.splice( i, 1 );\r\n\t\t\t\t\t\ti --;\r\n\t\t\t\t\t\tl --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// we're splitting with a quad and a triangle\r\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\r\n\t\t\t\t\t// sides have only a single vertex?\r\n\t\t\t\t\tconst singleVert =\r\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\r\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\r\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\r\n\r\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\r\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\r\n\t\t\t\t\t// correct winding order.\r\n\t\t\t\t\tif ( singleVert === 0 ) {\r\n\r\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\r\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\r\n\t\t\t\t\t\t_foundEdge.end = tmp;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\r\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\r\n\r\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\r\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\r\n\r\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\r\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\r\n\r\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\r\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\r\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\r\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\r\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\r\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\r\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\r\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\r\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\r\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\r\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\r\n\r\n\t\t\t\t\t// don't add degenerate triangles to the list\r\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.push( nextTri1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.push( nextTri2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// finish off the adjusted triangle\r\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.splice( i, 1 );\r\n\t\t\t\t\t\ti --;\r\n\t\t\t\t\t\tl --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( intersects === 3 ) {\r\n\r\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.triangles.length = 0;\r\n\t\tthis.trianglePool.clear();\r\n\t\tthis.coplanarTriangleUsed = false;\r\n\r\n\t}\r\n\r\n}\r\n", "import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\r\n\r\nfunction ceilToFourByteStride( byteLength ) {\r\n\r\n\tbyteLength = ~ ~ byteLength;\r\n\treturn byteLength + 4 - byteLength % 4;\r\n\r\n}\r\n\r\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\r\nexport class TypeBackedArray {\r\n\r\n\tconstructor( type, initialSize = 500 ) {\r\n\r\n\r\n\t\tthis.expansionFactor = 1.5;\r\n\t\tthis.type = type;\r\n\t\tthis.length = 0;\r\n\t\tthis.array = null;\r\n\r\n\t\tthis.setSize( initialSize );\r\n\r\n\t}\r\n\r\n\tsetType( type ) {\r\n\r\n\t\tif ( this.length !== 0 ) {\r\n\r\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst buffer = this.array.buffer;\r\n\t\tthis.array = new type( buffer );\r\n\t\tthis.type = type;\r\n\r\n\t}\r\n\r\n\tsetSize( size ) {\r\n\r\n\t\tif ( this.array && size === this.array.length ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\r\n\t\tconst type = this.type;\r\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\r\n\t\tif ( this.array ) {\r\n\r\n\t\t\tnewArray.set( this.array, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.array = newArray;\r\n\r\n\t}\r\n\r\n\texpand() {\r\n\r\n\t\tconst { array, expansionFactor } = this;\r\n\t\tthis.setSize( array.length * expansionFactor );\r\n\r\n\t}\r\n\r\n\tpush( ...args ) {\r\n\r\n\t\tlet { array, length } = this;\r\n\t\tif ( length + args.length > array.length ) {\r\n\r\n\t\t\tthis.expand();\r\n\t\t\tarray = this.array;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\r\n\r\n\t\t\tarray[ length + i ] = args[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.length += args.length;\r\n\r\n\t}\r\n\r\n\tclear() {\r\n\r\n\t\tthis.length = 0;\r\n\r\n\t}\r\n\r\n}\r\n", "import { TypeBackedArray } from './TypeBackedArray.js';\r\n\r\n// Utility class for for tracking attribute data in type-backed arrays for a set\r\n// of groups. The set of attributes is kept for each group and are expected to be the\r\n// same buffer type.\r\nexport class TypedAttributeData {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.groupAttributes = [ {} ];\r\n\t\tthis.groupCount = 0;\r\n\r\n\t}\r\n\r\n\t// returns the buffer type for the given attribute\r\n\tgetType( name ) {\r\n\r\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\r\n\r\n\t}\r\n\r\n\tgetItemSize( name ) {\r\n\r\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\r\n\r\n\t}\r\n\r\n\tgetNormalized( name ) {\r\n\r\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\r\n\r\n\t}\r\n\r\n\tgetCount( index ) {\r\n\r\n\t\tif ( this.groupCount <= index ) {\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\r\n\t\treturn pos.length / pos.itemSize;\r\n\r\n\t}\r\n\r\n\t// returns the total length required for all groups for the given attribute\r\n\tgetTotalLength( name ) {\r\n\r\n\t\tconst { groupCount, groupAttributes } = this;\r\n\r\n\t\tlet length = 0;\r\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\r\n\r\n\t\t\tconst attrSet = groupAttributes[ i ];\r\n\t\t\tlength += attrSet[ name ].length;\r\n\r\n\t\t}\r\n\r\n\t\treturn length;\r\n\r\n\t}\r\n\r\n\tgetGroupAttrSet( index = 0 ) {\r\n\r\n\t\t// TODO: can this be abstracted?\r\n\t\t// Return the exiting group set if necessary\r\n\t\tconst { groupAttributes } = this;\r\n\t\tif ( groupAttributes[ index ] ) {\r\n\r\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\r\n\t\t\treturn groupAttributes[ index ];\r\n\r\n\t\t}\r\n\r\n\t\t// add any new group sets required\r\n\t\tconst refAttrSet = groupAttributes[ 0 ];\r\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\r\n\t\twhile ( index >= groupAttributes.length ) {\r\n\r\n\t\t\tconst newAttrSet = {};\r\n\t\t\tgroupAttributes.push( newAttrSet );\r\n\t\t\tfor ( const key in refAttrSet ) {\r\n\r\n\t\t\t\tconst refAttr = refAttrSet[ key ];\r\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\r\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\r\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\r\n\t\t\t\tnewAttrSet[ key ] = newAttr;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn groupAttributes[ index ];\r\n\r\n\t}\r\n\r\n\t// Get the raw array for the group set of data\r\n\tgetGroupAttrArray( name, index = 0 ) {\r\n\r\n\t\t// throw an error if we've never\r\n\t\tconst { groupAttributes } = this;\r\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\r\n\t\tconst referenceAttr = referenceAttrSet[ name ];\r\n\t\tif ( ! referenceAttr ) {\r\n\r\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getGroupAttrSet( index )[ name ];\r\n\r\n\t}\r\n\r\n\t// initializes an attribute array with the given name, type, and size\r\n\tinitializeArray( name, type, itemSize, normalized ) {\r\n\r\n\t\tconst { groupAttributes } = this;\r\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\r\n\t\tconst referenceAttr = referenceAttrSet[ name ];\r\n\t\tif ( referenceAttr ) {\r\n\r\n\t\t\tif ( referenceAttr.type !== type ) {\r\n\r\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\r\n\t\t\t\t\tarr.setType( type );\r\n\t\t\t\t\tarr.itemSize = itemSize;\r\n\t\t\t\t\tarr.normalized = normalized;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst arr = new TypeBackedArray( type );\r\n\t\t\t\tarr.itemSize = itemSize;\r\n\t\t\t\tarr.normalized = normalized;\r\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Clear all the data\r\n\tclear() {\r\n\r\n\t\tthis.groupCount = 0;\r\n\r\n\t\tconst { groupAttributes } = this;\r\n\t\tgroupAttributes.forEach( attrSet => {\r\n\r\n\t\t\tfor ( const key in attrSet ) {\r\n\r\n\t\t\t\tattrSet[ key ].clear();\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Remove the given key\r\n\tdelete( key ) {\r\n\r\n\t\tthis.groupAttributes.forEach( attrSet => {\r\n\r\n\t\t\tdelete attrSet[ key ];\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Reset the datasets completely\r\n\treset() {\r\n\r\n\t\tthis.groupAttributes = [];\r\n\t\tthis.groupCount = 0;\r\n\r\n\t}\r\n\r\n}\r\n", "export class IntersectionMap {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.intersectionSet = {};\r\n\t\tthis.ids = [];\r\n\r\n\t}\r\n\r\n\tadd( id, intersectionId ) {\r\n\r\n\t\tconst { intersectionSet, ids } = this;\r\n\t\tif ( ! intersectionSet[ id ] ) {\r\n\r\n\t\t\tintersectionSet[ id ] = [];\r\n\t\t\tids.push( id );\r\n\r\n\t\t}\r\n\r\n\t\tintersectionSet[ id ].push( intersectionId );\r\n\r\n\t}\r\n\r\n}\r\n", "export const ADDITION = 0;\r\nexport const SUBTRACTION = 1;\r\nexport const REVERSE_SUBTRACTION = 2;\r\nexport const INTERSECTION = 3;\r\nexport const DIFFERENCE = 4;\r\n\r\n// guaranteed non manifold results\r\nexport const HOLLOW_SUBTRACTION = 5;\r\nexport const HOLLOW_INTERSECTION = 6;\r\n", "import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\r\nimport { IntersectionMap } from '../IntersectionMap.js';\r\nimport {\r\n\tADDITION,\r\n\tSUBTRACTION,\r\n\tREVERSE_SUBTRACTION,\r\n\tINTERSECTION,\r\n\tDIFFERENCE,\r\n\tHOLLOW_SUBTRACTION,\r\n\tHOLLOW_INTERSECTION,\r\n} from '../constants.js';\r\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\r\n\r\nconst _ray = new Ray();\r\nconst _matrix = new Matrix4();\r\nconst _tri = new Triangle();\r\nconst _vec3 = new Vector3();\r\nconst _vec4a = new Vector4();\r\nconst _vec4b = new Vector4();\r\nconst _vec4c = new Vector4();\r\nconst _vec4_0 = new Vector4();\r\nconst _vec4_1 = new Vector4();\r\nconst _vec4_2 = new Vector4();\r\nconst _edge = new Line3();\r\nconst _normal = new Vector3();\r\nconst JITTER_EPSILON = 1e-8;\r\nconst OFFSET_EPSILON = 1e-15;\r\n\r\nexport const BACK_SIDE = - 1;\r\nexport const FRONT_SIDE = 1;\r\nexport const COPLANAR_OPPOSITE = - 2;\r\nexport const COPLANAR_ALIGNED = 2;\r\n\r\nexport const INVERT_TRI = 0;\r\nexport const ADD_TRI = 1;\r\nexport const SKIP_TRI = 2;\r\n\r\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\r\n\r\nlet _debugContext = null;\r\nexport function setDebugContext( debugData ) {\r\n\r\n\t_debugContext = debugData;\r\n\r\n}\r\n\r\nexport function getHitSide( tri, bvh ) {\r\n\r\n\ttri.getMidpoint( _ray.origin );\r\n\ttri.getNormal( _ray.direction );\r\n\r\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\r\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\r\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\r\n\r\n}\r\n\r\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\r\n\r\n\t// random function that returns [ - 0.5, 0.5 ];\r\n\tfunction rand() {\r\n\r\n\t\treturn Math.random() - 0.5;\r\n\r\n\t}\r\n\r\n\t// get the ray the check the triangle for\r\n\ttri.getNormal( _normal );\r\n\t_ray.direction.copy( _normal );\r\n\ttri.getMidpoint( _ray.origin );\r\n\r\n\tconst total = 3;\r\n\tlet count = 0;\r\n\tlet minDistance = Infinity;\r\n\tfor ( let i = 0; i < total; i ++ ) {\r\n\r\n\t\t// jitter the ray slightly\r\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\r\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\r\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\r\n\r\n\t\t// and invert it so we can account for floating point error by checking both directions\r\n\t\t// to catch coplanar distances\r\n\t\t_ray.direction.multiplyScalar( - 1 );\r\n\r\n\t\t// check if the ray hit the backside\r\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\r\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\r\n\t\tif ( hitBackSide ) {\r\n\r\n\t\t\tcount ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( hit !== null ) {\r\n\r\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\r\n\r\n\t\t}\r\n\r\n\t\t// if we're right up against another face then we're coplanar\r\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\r\n\r\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\r\n\r\n\t\t}\r\n\r\n\t\t// if our current casts meet our requirements then early out\r\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\r\n\r\n}\r\n\r\n// returns the intersected triangles and returns objects mapping triangle indices to\r\n// the other triangles intersected\r\nexport function collectIntersectingTriangles( a, b ) {\r\n\r\n\tconst aIntersections = new IntersectionMap();\r\n\tconst bIntersections = new IntersectionMap();\r\n\r\n\t_matrix\r\n\t\t.copy( a.matrixWorld )\r\n\t\t.invert()\r\n\t\t.multiply( b.matrixWorld );\r\n\r\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\r\n\r\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\r\n\r\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\r\n\r\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\r\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\r\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\r\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\r\n\t\t\t\tif ( ! intersected ) {\r\n\r\n\t\t\t\t\tconst pa = triangleA.plane;\r\n\t\t\t\t\tconst pb = triangleB.plane;\r\n\t\t\t\t\tconst na = pa.normal;\r\n\t\t\t\t\tconst nb = pb.normal;\r\n\r\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\t\tintersected = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( intersected ) {\r\n\r\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\r\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\r\n\t\t\t\t\taIntersections.add( va, vb );\r\n\t\t\t\t\tbIntersections.add( vb, va );\r\n\r\n\t\t\t\t\tif ( _debugContext ) {\r\n\r\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\r\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn { aIntersections, bIntersections };\r\n\r\n}\r\n\r\n// Add the barycentric interpolated values fro the triangle into the new attribute data\r\nexport function appendAttributeFromTriangle(\r\n\ttriIndex,\r\n\tbaryCoordTri,\r\n\tgeometry,\r\n\tmatrixWorld,\r\n\tnormalMatrix,\r\n\tattributeData,\r\n\tinvert = false,\r\n) {\r\n\r\n\tconst attributes = geometry.attributes;\r\n\tconst indexAttr = geometry.index;\r\n\tconst i3 = triIndex * 3;\r\n\tconst i0 = indexAttr.getX( i3 + 0 );\r\n\tconst i1 = indexAttr.getX( i3 + 1 );\r\n\tconst i2 = indexAttr.getX( i3 + 2 );\r\n\r\n\tfor ( const key in attributeData ) {\r\n\r\n\t\t// check if the key we're asking for is in the geometry at all\r\n\t\tconst attr = attributes[ key ];\r\n\t\tconst arr = attributeData[ key ];\r\n\t\tif ( ! ( key in attributes ) ) {\r\n\r\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\r\n\r\n\t\t}\r\n\r\n\t\t// handle normals and positions specially because they require transforming\r\n\t\t// TODO: handle tangents\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tif ( key === 'position' ) {\r\n\r\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\r\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\r\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\r\n\r\n\t\t} else if ( key === 'normal' ) {\r\n\r\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\r\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\r\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\r\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\r\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\r\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\r\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\r\n\r\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Append all the values of the attributes for the triangle onto the new attribute arrays\r\nexport function appendAttributesFromIndices(\r\n\ti0,\r\n\ti1,\r\n\ti2,\r\n\tattributes,\r\n\tmatrixWorld,\r\n\tnormalMatrix,\r\n\tattributeData,\r\n\tinvert = false,\r\n) {\r\n\r\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\r\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\r\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\r\n\r\n}\r\n\r\n// Returns the triangle to add when performing an operation\r\nexport function getOperationAction( operation, hitSide, invert = false ) {\r\n\r\n\tswitch ( operation ) {\r\n\r\n\t\tcase ADDITION:\r\n\r\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase SUBTRACTION:\r\n\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\r\n\r\n\t\t\t\t\treturn INVERT_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\r\n\r\n\t\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase REVERSE_SUBTRACTION:\r\n\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\r\n\r\n\t\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\r\n\r\n\t\t\t\t\treturn INVERT_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase DIFFERENCE:\r\n\r\n\t\t\tif ( hitSide === BACK_SIDE ) {\r\n\r\n\t\t\t\treturn INVERT_TRI;\r\n\r\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase INTERSECTION:\r\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase HOLLOW_SUBTRACTION:\r\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase HOLLOW_INTERSECTION:\r\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\r\n\r\n\t}\r\n\r\n\treturn SKIP_TRI;\r\n\r\n}\r\n\r\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\r\n// and whether to invert the result and pushes the new values onto the provided attribute array\r\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\r\n\r\n\t// adds the appropriate number of values for the vector onto the array\r\n\tconst addValues = v => {\r\n\r\n\t\tattrArr.push( v.x );\r\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\r\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\r\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\r\n\r\n\t};\r\n\r\n\t// barycentric interpolate the first component\r\n\t_vec4_0.set( 0, 0, 0, 0 )\r\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\r\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\r\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\r\n\r\n\t_vec4_1.set( 0, 0, 0, 0 )\r\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\r\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\r\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\r\n\r\n\t_vec4_2.set( 0, 0, 0, 0 )\r\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\r\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\r\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\r\n\r\n\tif ( normalize ) {\r\n\r\n\t\t_vec4_0.normalize();\r\n\t\t_vec4_1.normalize();\r\n\t\t_vec4_2.normalize();\r\n\r\n\t}\r\n\r\n\t// if the face is inverted then add the values in an inverted order\r\n\taddValues( _vec4_0 );\r\n\r\n\tif ( invert ) {\r\n\r\n\t\taddValues( _vec4_2 );\r\n\t\taddValues( _vec4_1 );\r\n\r\n\t} else {\r\n\r\n\t\taddValues( _vec4_1 );\r\n\t\taddValues( _vec4_2 );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Adds the values for the given vertex index onto the new attribute arrays\r\nfunction appendAttributeFromIndex(\r\n\tindex,\r\n\tattributes,\r\n\tmatrixWorld,\r\n\tnormalMatrix,\r\n\tattributeData,\r\n\tinvert = false,\r\n) {\r\n\r\n\tfor ( const key in attributeData ) {\r\n\r\n\t\t// check if the key we're asking for is in the geometry at all\r\n\t\tconst attr = attributes[ key ];\r\n\t\tconst arr = attributeData[ key ];\r\n\t\tif ( ! ( key in attributes ) ) {\r\n\r\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\r\n\r\n\t\t}\r\n\r\n\t\t// specially handle the position and normal attributes because they require transforms\r\n\t\t// TODO: handle tangents\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tif ( key === 'position' ) {\r\n\r\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\r\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\r\n\r\n\t\t} else if ( key === 'normal' ) {\r\n\r\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\t_vec3.multiplyScalar( - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarr.push( attr.getX( index ) );\r\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\r\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\r\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Triangle } from 'three';\r\nimport { setDebugContext } from '../operations/operationsUtils.js';\r\n\r\nclass TriangleIntersectData {\r\n\r\n\tconstructor( tri ) {\r\n\r\n\t\tthis.triangle = new Triangle().copy( tri );\r\n\t\tthis.intersects = {};\r\n\r\n\t}\r\n\r\n\taddTriangle( index, tri ) {\r\n\r\n\t\tthis.intersects[ index ] = new Triangle().copy( tri );\r\n\r\n\t}\r\n\r\n\tgetIntersectArray() {\r\n\r\n\t\tconst array = [];\r\n\t\tconst { intersects } = this;\r\n\t\tfor ( const key in intersects ) {\r\n\r\n\t\t\tarray.push( intersects[ key ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass TriangleIntersectionSets {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.data = {};\r\n\r\n\t}\r\n\r\n\taddTriangleIntersection( ia, triA, ib, triB ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tif ( ! data[ ia ] ) {\r\n\r\n\t\t\tdata[ ia ] = new TriangleIntersectData( triA );\r\n\r\n\t\t}\r\n\r\n\t\tdata[ ia ].addTriangle( ib, triB );\r\n\r\n\t}\r\n\r\n\tgetTrianglesAsArray( id = null ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tconst arr = [];\r\n\r\n\t\tif ( id !== null ) {\r\n\r\n\t\t\tif ( id in data ) {\r\n\r\n\t\t\t\tarr.push( data[ id ].triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( const key in data ) {\r\n\r\n\t\t\t\tarr.push( data[ key ].triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn arr;\r\n\r\n\t}\r\n\r\n\tgetTriangleIndices() {\r\n\r\n\t\treturn Object.keys( this.data ).map( i => parseInt( i ) );\r\n\r\n\t}\r\n\r\n\tgetIntersectionIndices( id ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tif ( ! data[ id ] ) {\r\n\r\n\t\t\treturn [];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn Object.keys( data[ id ].intersects ).map( i => parseInt( i ) );\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetIntersectionsAsArray( id = null, id2 = null ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tconst triSet = new Set();\r\n\t\tconst arr = [];\r\n\r\n\t\tconst addTriangles = key => {\r\n\r\n\t\t\tif ( ! data[ key ] ) return;\r\n\r\n\t\t\tif ( id2 !== null ) {\r\n\r\n\t\t\t\tif ( data[ key ].intersects[ id2 ] ) {\r\n\r\n\t\t\t\t\tarr.push( data[ key ].intersects[ id2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst intersects = data[ key ].intersects;\r\n\t\t\t\tfor ( const key2 in intersects ) {\r\n\r\n\t\t\t\t\tif ( ! triSet.has( key2 ) ) {\r\n\r\n\t\t\t\t\t\ttriSet.add( key2 );\r\n\t\t\t\t\t\tarr.push( intersects[ key2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tif ( id !== null ) {\r\n\r\n\t\t\taddTriangles( id );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( const key in data ) {\r\n\r\n\t\t\t\taddTriangles( key );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn arr;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.data = {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class OperationDebugData {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.enabled = false;\r\n\t\tthis.triangleIntersectsA = new TriangleIntersectionSets();\r\n\t\tthis.triangleIntersectsB = new TriangleIntersectionSets();\r\n\t\tthis.intersectionEdges = [];\r\n\r\n\t}\r\n\r\n\taddIntersectingTriangles( ia, triA, ib, triB ) {\r\n\r\n\t\tconst { triangleIntersectsA, triangleIntersectsB } = this;\r\n\t\ttriangleIntersectsA.addTriangleIntersection( ia, triA, ib, triB );\r\n\t\ttriangleIntersectsB.addTriangleIntersection( ib, triB, ia, triA );\r\n\r\n\t}\r\n\r\n\taddEdge( edge ) {\r\n\r\n\t\tthis.intersectionEdges.push( edge.clone() );\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.triangleIntersectsA.reset();\r\n\t\tthis.triangleIntersectsB.reset();\r\n\t\tthis.intersectionEdges = [];\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tthis.reset();\r\n\t\t\tsetDebugContext( this );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomplete() {\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tsetDebugContext( null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Matrix4, Matrix3, Triangle } from 'three';\r\nimport {\r\n\tgetHitSideWithCoplanarCheck,\r\n\tgetHitSide,\r\n\tcollectIntersectingTriangles,\r\n\tappendAttributeFromTriangle,\r\n\tappendAttributesFromIndices,\r\n\tgetOperationAction,\r\n\tSKIP_TRI, INVERT_TRI,\r\n} from './operationsUtils.js';\r\nimport { getTriCount } from '../utils/geometryUtils.js';\r\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\r\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\r\n\r\nconst _matrix = new Matrix4();\r\nconst _normalMatrix = new Matrix3();\r\nconst _triA = new Triangle();\r\nconst _triB = new Triangle();\r\nconst _tri = new Triangle();\r\nconst _barycoordTri = new Triangle();\r\nconst _attr = [];\r\nconst _actions = [];\r\n\r\nfunction getFirstIdFromSet( set ) {\r\n\r\n\tfor ( const id of set ) return id;\r\n\r\n}\r\n\r\n// runs the given operation against a and b using the splitter and appending data to the\r\n// attributeData object.\r\nexport function performOperation(\r\n\ta,\r\n\tb,\r\n\toperations,\r\n\tsplitter,\r\n\tattributeData,\r\n\toptions = {},\r\n) {\r\n\r\n\tconst { useGroups = true } = options;\r\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\r\n\r\n\tconst resultGroups = [];\r\n\tlet resultMaterials = null;\r\n\r\n\tlet groupOffset;\r\n\tgroupOffset = useGroups ? 0 : - 1;\r\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\r\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\r\n\r\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\r\n\t// to perform the second set of triangle additions\r\n\tconst nonHollow = operations\r\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\r\n\r\n\tif ( nonHollow ) {\r\n\r\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\r\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\r\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\r\n\r\n\t}\r\n\r\n\t_attr.length = 0;\r\n\t_actions.length = 0;\r\n\r\n\treturn {\r\n\t\tgroups: resultGroups,\r\n\t\tmaterials: resultMaterials\r\n\t};\r\n\r\n}\r\n\r\n// perform triangle splitting and CSG operations on the set of split triangles\r\nfunction performSplitTriangleOperations(\r\n\ta,\r\n\tb,\r\n\tintersectionMap,\r\n\toperations,\r\n\tinvert,\r\n\tsplitter,\r\n\tattributeData,\r\n\tgroupOffset = 0,\r\n) {\r\n\r\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\r\n\r\n\t// transforms into the local frame of matrix b\r\n\t_matrix\r\n\t\t.copy( b.matrixWorld )\r\n\t\t.invert()\r\n\t\t.multiply( a.matrixWorld );\r\n\r\n\t_normalMatrix\r\n\t\t.getNormalMatrix( a.matrixWorld )\r\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\r\n\r\n\tconst groupIndices = a.geometry.groupIndices;\r\n\tconst aIndex = a.geometry.index;\r\n\tconst aPosition = a.geometry.attributes.position;\r\n\r\n\tconst bBVH = b.geometry.boundsTree;\r\n\tconst bIndex = b.geometry.index;\r\n\tconst bPosition = b.geometry.attributes.position;\r\n\tconst splitIds = intersectionMap.ids;\r\n\tconst intersectionSet = intersectionMap.intersectionSet;\r\n\r\n\t// iterate over all split triangle indices\r\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\r\n\r\n\t\tconst ia = splitIds[ i ];\r\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\r\n\r\n\t\t// get the triangle in the geometry B local frame\r\n\t\tconst ia3 = 3 * ia;\r\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\r\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\r\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\r\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\r\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\r\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\r\n\r\n\t\t// initialize the splitter with the triangle from geometry A\r\n\t\tsplitter.reset();\r\n\t\tsplitter.initialize( _triA );\r\n\r\n\t\t// split the triangle with the intersecting triangles from B\r\n\t\tconst intersectingIndices = intersectionSet[ ia ];\r\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\r\n\r\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\r\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\r\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\r\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\r\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\r\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\r\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\r\n\t\t\tsplitter.splitByTriangle( _triB );\r\n\r\n\t\t}\r\n\r\n\t\t// for all triangles in the split result\r\n\t\tconst triangles = splitter.triangles;\r\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\r\n\r\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\r\n\t\t\tconst clippedTri = triangles[ ib ];\r\n\r\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\r\n\t\t\t// uncertain then fall back to the raycasting approach\r\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\r\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\r\n\t\t\t\tgetHitSide( clippedTri, bBVH );\r\n\r\n\t\t\t_attr.length = 0;\r\n\t\t\t_actions.length = 0;\r\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\r\n\r\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\r\n\t\t\t\tif ( op !== SKIP_TRI ) {\r\n\r\n\t\t\t\t\t_actions.push( op );\r\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _attr.length !== 0 ) {\r\n\r\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\r\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\r\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\r\n\r\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\r\n\r\n\t\t\t\t\tconst attrSet = _attr[ k ];\r\n\t\t\t\t\tconst action = _actions[ k ];\r\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\r\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitIds.length;\r\n\r\n}\r\n\r\n// perform CSG operations on the set of whole triangles using a half edge structure\r\n// at the moment this isn't always faster due to overhead of building the half edge structure\r\n// and degraded connectivity due to split triangles.\r\n\r\nfunction performWholeTriangleOperations(\r\n\ta,\r\n\tb,\r\n\tsplitTriSet,\r\n\toperations,\r\n\tinvert,\r\n\tattributeData,\r\n\tgroupOffset = 0,\r\n) {\r\n\r\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\r\n\r\n\t// matrix for transforming into the local frame of geometry b\r\n\t_matrix\r\n\t\t.copy( b.matrixWorld )\r\n\t\t.invert()\r\n\t\t.multiply( a.matrixWorld );\r\n\r\n\t_normalMatrix\r\n\t\t.getNormalMatrix( a.matrixWorld )\r\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\r\n\r\n\tconst bBVH = b.geometry.boundsTree;\r\n\tconst groupIndices = a.geometry.groupIndices;\r\n\tconst aIndex = a.geometry.index;\r\n\tconst aAttributes = a.geometry.attributes;\r\n\tconst aPosition = aAttributes.position;\r\n\r\n\tconst stack = [];\r\n\tconst halfEdges = a.geometry.halfEdges;\r\n\tconst traverseSet = new Set();\r\n\tconst triCount = getTriCount( a.geometry );\r\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\r\n\r\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\r\n\r\n\t\t\ttraverseSet.add( i );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\twhile ( traverseSet.size > 0 ) {\r\n\r\n\t\tconst id = getFirstIdFromSet( traverseSet );\r\n\t\ttraverseSet.delete( id );\r\n\r\n\t\tstack.push( id );\r\n\r\n\t\t// get the vertex indices\r\n\t\tconst i3 = 3 * id;\r\n\t\tconst i0 = aIndex.getX( i3 + 0 );\r\n\t\tconst i1 = aIndex.getX( i3 + 1 );\r\n\t\tconst i2 = aIndex.getX( i3 + 2 );\r\n\r\n\t\t// get the vertex position in the frame of geometry b so we can\r\n\t\t// perform hit testing\r\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\r\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\r\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\r\n\r\n\t\t// get the side and decide if we need to cull the triangle based on the operation\r\n\t\tconst hitSide = getHitSide( _tri, bBVH );\r\n\r\n\t\t_actions.length = 0;\r\n\t\t_attr.length = 0;\r\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\r\n\r\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\r\n\t\t\tif ( op !== SKIP_TRI ) {\r\n\r\n\t\t\t\t_actions.push( op );\r\n\t\t\t\t_attr.push( attributeData[ o ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\twhile ( stack.length > 0 ) {\r\n\r\n\t\t\tconst currId = stack.pop();\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\r\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\r\n\r\n\t\t\t\t\tstack.push( sid );\r\n\t\t\t\t\ttraverseSet.delete( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _attr.length !== 0 ) {\r\n\r\n\t\t\t\tconst i3 = 3 * currId;\r\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\r\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\r\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\r\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\r\n\r\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\r\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\r\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\r\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\r\n\r\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\r\n\r\n\t\t\t\t\t\tconst action = _actions[ k ];\r\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\r\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\r\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n", "import { BufferAttribute } from 'three';\r\nimport { TriangleSplitter } from './TriangleSplitter.js';\r\nimport { TypedAttributeData } from './TypedAttributeData.js';\r\nimport { OperationDebugData } from './debug/OperationDebugData.js';\r\nimport { performOperation } from './operations/operations.js';\r\nimport { Brush } from './Brush.js';\r\n\r\n// merges groups with common material indices in place\r\nfunction joinGroups( groups ) {\r\n\r\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst nextGroup = groups[ i + 1 ];\r\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\r\n\r\n\t\t\tconst start = group.start;\r\n\t\t\tconst end = nextGroup.start + nextGroup.count;\r\n\t\t\tnextGroup.start = start;\r\n\t\t\tnextGroup.count = end - start;\r\n\r\n\t\t\tgroups.splice( i, 1 );\r\n\t\t\ti --;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// initialize the target geometry and attribute data to be based on\r\n// the given reference geometry\r\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\r\n\r\n\tattributeData.clear();\r\n\r\n\t// initialize and clear unused data from the attribute buffers and vice versa\r\n\tconst aAttributes = referenceGeometry.attributes;\r\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\r\n\r\n\t\tconst key = relevantAttributes[ i ];\r\n\t\tconst aAttr = aAttributes[ key ];\r\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\r\n\r\n\t}\r\n\r\n\tfor ( const key in attributeData.attributes ) {\r\n\r\n\t\tif ( ! relevantAttributes.includes( key ) ) {\r\n\r\n\t\t\tattributeData.delete( key );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\tif ( ! relevantAttributes.includes( key ) ) {\r\n\r\n\t\t\ttargetGeometry.deleteAttribute( key );\r\n\t\t\ttargetGeometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Assigns the given tracked attribute data to the geometry and returns whether the\r\n// geometry needs to be disposed of.\r\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\r\n\r\n\tlet needsDisposal = false;\r\n\tlet drawRange = - 1;\r\n\r\n\t// set the data\r\n\tconst attributes = geometry.attributes;\r\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\r\n\tfor ( const key in referenceAttrSet ) {\r\n\r\n\t\tconst requiredLength = attributeData.getTotalLength( key );\r\n\t\tconst type = attributeData.getType( key );\r\n\t\tconst itemSize = attributeData.getItemSize( key );\r\n\t\tconst normalized = attributeData.getNormalized( key );\r\n\t\tlet geoAttr = attributes[ key ];\r\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\r\n\r\n\t\t\t// create the attribute if it doesn't exist yet\r\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\r\n\t\t\tgeometry.setAttribute( key, geoAttr );\r\n\t\t\tneedsDisposal = true;\r\n\r\n\t\t}\r\n\r\n\t\t// assign the data to the geometry attribute buffers in the provided order\r\n\t\t// of the groups list\r\n\t\tlet offset = 0;\r\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\r\n\r\n\t\t\tconst index = groupOrder[ i ].index;\r\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\r\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\r\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\r\n\t\t\toffset += trimmedArray.length;\r\n\r\n\t\t}\r\n\r\n\t\tgeoAttr.needsUpdate = true;\r\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\r\n\r\n\t}\r\n\r\n\t// remove or update the index appropriately\r\n\tif ( geometry.index ) {\r\n\r\n\t\tconst indexArray = geometry.index.array;\r\n\t\tif ( indexArray.length < drawRange ) {\r\n\r\n\t\t\tgeometry.index = null;\r\n\t\t\tneedsDisposal = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindexArray[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// initialize the groups\r\n\tlet groupOffset = 0;\r\n\tgeometry.clearGroups();\r\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\r\n\r\n\t\tconst { index, materialIndex } = groupOrder[ i ];\r\n\t\tconst vertCount = attributeData.getCount( index );\r\n\t\tif ( vertCount !== 0 ) {\r\n\r\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\r\n\t\t\tgroupOffset += vertCount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// update the draw range\r\n\tgeometry.setDrawRange( 0, drawRange );\r\n\r\n\t// remove the bounds tree if it exists because its now out of date\r\n\t// TODO: can we have this dispose in the same way that a brush does?\r\n\t// TODO: why are half edges and group indices not removed here?\r\n\tgeometry.boundsTree = null;\r\n\r\n\tif ( needsDisposal ) {\r\n\r\n\t\tgeometry.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Returns the list of materials used for the given set of groups\r\nfunction getMaterialList( groups, materials ) {\r\n\r\n\tlet result = materials;\r\n\tif ( ! Array.isArray( materials ) ) {\r\n\r\n\t\tresult = [];\r\n\t\tgroups.forEach( g => {\r\n\r\n\t\t\tresult[ g.materialIndex ] = materials;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n// Utility class for performing CSG operations\r\nexport class Evaluator {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.triangleSplitter = new TriangleSplitter();\r\n\t\tthis.attributeData = [];\r\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\r\n\t\tthis.useGroups = true;\r\n\t\tthis.consolidateGroups = true;\r\n\t\tthis.debug = new OperationDebugData();\r\n\r\n\t}\r\n\r\n\tgetGroupRanges( geometry ) {\r\n\r\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\r\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\r\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\r\n\r\n\t}\r\n\r\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\r\n\r\n\t\tlet wasArray = true;\r\n\t\tif ( ! Array.isArray( operations ) ) {\r\n\r\n\t\t\toperations = [ operations ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\r\n\r\n\t\t\ttargetBrushes = [ targetBrushes ];\r\n\t\t\twasArray = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( targetBrushes.length !== operations.length ) {\r\n\r\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\r\n\r\n\t\t}\r\n\r\n\t\ta.prepareGeometry();\r\n\t\tb.prepareGeometry();\r\n\r\n\t\tconst {\r\n\t\t\ttriangleSplitter,\r\n\t\t\tattributeData,\r\n\t\t\tattributes,\r\n\t\t\tuseGroups,\r\n\t\t\tconsolidateGroups,\r\n\t\t\tdebug,\r\n\t\t} = this;\r\n\r\n\t\t// expand the attribute data array to the necessary size\r\n\t\twhile ( attributeData.length < targetBrushes.length ) {\r\n\r\n\t\t\tattributeData.push( new TypedAttributeData() );\r\n\r\n\t\t}\r\n\r\n\t\t// prepare the attribute data buffer information\r\n\t\ttargetBrushes.forEach( ( brush, i ) => {\r\n\r\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\r\n\r\n\t\t} );\r\n\r\n\t\t// run the operation to fill the list of attribute data\r\n\t\tdebug.init();\r\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\r\n\t\tdebug.complete();\r\n\r\n\t\t// get the materials and group ranges\r\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\r\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\r\n\r\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\r\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\r\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\r\n\r\n\t\tlet groups = [ ...aGroups, ...bGroups ]\r\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\r\n\r\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\r\n\t\t// if they're needed\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\r\n\t\t\tif ( consolidateGroups ) {\r\n\r\n\t\t\t\tgroups = groups\r\n\t\t\t\t\t.map( group => {\r\n\r\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\r\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\r\n\t\t\t\t\t\treturn group;\r\n\r\n\t\t\t\t\t} )\r\n\t\t\t\t\t.sort( ( a, b ) => {\r\n\r\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// create a map from old to new index and remove materials that aren't used\r\n\t\t\tconst finalMaterials = [];\r\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tlet foundGroup = false;\r\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\r\n\r\n\t\t\t\t\tconst group = groups[ g ];\r\n\t\t\t\t\tif ( group.materialIndex === i ) {\r\n\r\n\t\t\t\t\t\tfoundGroup = true;\r\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( foundGroup ) {\r\n\r\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetBrushes.forEach( tb => {\r\n\r\n\t\t\t\ttb.material = finalMaterials;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\r\n\t\t\ttargetBrushes.forEach( tb => {\r\n\r\n\t\t\t\ttb.material = aMaterials[ 0 ];\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t// apply groups and attribute data to the geometry\r\n\t\ttargetBrushes.forEach( ( brush, i ) => {\r\n\r\n\t\t\tconst targetGeometry = brush.geometry;\r\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\r\n\t\t\tif ( consolidateGroups ) {\r\n\r\n\t\t\t\tjoinGroups( targetGeometry.groups );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\r\n\r\n\t}\r\n\r\n\t// TODO: fix\r\n\tevaluateHierarchy( root, target = new Brush() ) {\r\n\r\n\t\troot.updateMatrixWorld( true );\r\n\r\n\t\tconst flatTraverse = ( obj, cb ) => {\r\n\r\n\t\t\tconst children = obj.children;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = children[ i ];\r\n\t\t\t\tif ( child.isOperationGroup ) {\r\n\r\n\t\t\t\t\tflatTraverse( child, cb );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcb( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\tconst traverse = brush => {\r\n\r\n\t\t\tconst children = brush.children;\r\n\t\t\tlet didChange = false;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = children[ i ];\r\n\t\t\t\tdidChange = traverse( child ) || didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isDirty = brush.isDirty();\r\n\t\t\tif ( isDirty ) {\r\n\r\n\t\t\t\tbrush.markUpdated();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\r\n\r\n\t\t\t\tlet result;\r\n\t\t\t\tflatTraverse( brush, child => {\r\n\r\n\t\t\t\t\tif ( ! result ) {\r\n\r\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tbrush._cachedGeometry = result.geometry;\r\n\t\t\t\tbrush._cachedMaterials = result.material;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn didChange || isDirty;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\ttraverse( root );\r\n\r\n\t\ttarget.geometry = root._cachedGeometry;\r\n\t\ttarget.material = root._cachedMaterials;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.triangleSplitter.reset();\r\n\r\n\t}\r\n\r\n}\r\n", "import { BufferGeometry } from 'three';\r\nimport { Brush } from '../Brush.js';\r\nimport { ADDITION } from '../constants.js';\r\n\r\nexport class Operation extends Brush {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOperation = true;\r\n\t\tthis.operation = ADDITION;\r\n\r\n\t\tthis._cachedGeometry = new BufferGeometry();\r\n\t\tthis._cachedMaterials = null;\r\n\t\tthis._previousOperation = null;\r\n\r\n\t}\r\n\r\n\tmarkUpdated() {\r\n\r\n\t\tsuper.markUpdated();\r\n\t\tthis._previousOperation = this.operation;\r\n\r\n\t}\r\n\r\n\tisDirty() {\r\n\r\n\t\treturn this.operation !== this._previousOperation || super.isDirty();\r\n\r\n\t}\r\n\r\n\tinsertBefore( brush ) {\r\n\r\n\t\tconst parent = this.parent;\r\n\t\tconst index = parent.children.indexOf( this );\r\n\t\tparent.children.splice( index, 0, brush );\r\n\r\n\t}\r\n\r\n\tinsertAfter( brush ) {\r\n\r\n\t\tconst parent = this.parent;\r\n\t\tconst index = parent.children.indexOf( this );\r\n\t\tparent.children.splice( index + 1, 0, brush );\r\n\r\n\t}\r\n\r\n}\r\n", "import { Group, Matrix4 } from 'three';\r\n\r\nexport class OperationGroup extends Group {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.isOperationGroup = true;\r\n\t\tthis._previousMatrix = new Matrix4();\r\n\r\n\t}\r\n\r\n\tmarkUpdated() {\r\n\r\n\t\tthis._previousMatrix.copy( this.matrix );\r\n\r\n\t}\r\n\r\n\tisDirty() {\r\n\r\n\t\tconst { matrix, _previousMatrix } = this;\r\n\t\tconst el1 = matrix.elements;\r\n\t\tconst el2 = _previousMatrix.elements;\r\n\t\tfor ( let i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Color } from 'three';\r\n\r\nfunction addWorldPosition( shader ) {\r\n\r\n\tif ( /varying\\s+vec3\\s+wPosition/.test( shader.vertexShader ) ) return;\r\n\r\n\tshader.vertexShader = `\r\n\t\t\tvarying vec3 wPosition;\r\n\t\t\t${shader.vertexShader}\r\n\t\t`.replace(\r\n\t\t/#include <displacementmap_vertex>/,\r\n\t\tv =>\r\n\t\t\t`${v}\r\n\t\t\t\twPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;\r\n\t\t\t\t`,\r\n\t);\r\n\r\n\tshader.fragmentShader = `\r\n\t\tvarying vec3 wPosition;\r\n\t\t${shader.fragmentShader}\r\n\t\t`;\r\n\r\n\treturn shader;\r\n\r\n}\r\n\r\nexport function csgGridShaderMixin( shader ) {\r\n\r\n\tshader.uniforms = {\r\n\t\t...shader.uniforms,\r\n\t\tcheckerboardColor: { value: new Color( 0x111111 ) }\r\n\t};\r\n\r\n\taddWorldPosition( shader );\r\n\r\n\tshader.defines = { CSG_GRID: 1 };\r\n\r\n\tshader.fragmentShader = shader.fragmentShader.replace(\r\n\t\t/#include <common>/,\r\n\t\tv =>\r\n\t\t/* glsl */`\r\n\t\t\t${v}\r\n\r\n\t\t\tuniform vec3 checkerboardColor;\r\n\t\t\tfloat getCheckerboard( vec2 p, float scale ) {\r\n\r\n\t\t\t\tp /= scale;\r\n\t\t\t\tp += vec2( 0.5 );\r\n\r\n\t\t\t\tvec2 line = mod( p, 2.0 ) - vec2( 1.0 );\r\n\t\t\t\tline = abs( line );\r\n\r\n\t\t\t\tvec2 pWidth = fwidth( line );\r\n\t\t\t\tvec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );\r\n\t\t\t\tfloat result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );\r\n\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat getGrid( vec2 p, float scale, float thickness ) {\r\n\r\n\t\t\t\tp /= 0.5 * scale;\r\n\r\n\t\t\t\tvec2 stride = mod( p, 2.0 ) - vec2( 1.0 );\r\n\t\t\t\tstride = abs( stride );\r\n\r\n\t\t\t\tvec2 pWidth = fwidth( p );\r\n\t\t\t\tvec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );\r\n\r\n\t\t\t\treturn max( line.x, line.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec3 getFaceColor( vec2 p, vec3 color ) {\r\n\r\n\t\t\t\tfloat checkLarge = getCheckerboard( p, 1.0 );\r\n\t\t\t\tfloat checkSmall = abs( getCheckerboard( p, 0.1 ) );\r\n\t\t\t\tfloat lines = getGrid( p, 10.0, 1.0 );\r\n\r\n\t\t\t\tvec3 checkColor = mix(\r\n\t\t\t\t\tvec3( 0.7 ) * color,\r\n\t\t\t\t\tvec3( 1.0 ) * color,\r\n\t\t\t\t\tcheckSmall * 0.4 + checkLarge * 0.6\r\n\t\t\t\t);\r\n\r\n\t\t\t\tvec3 gridColor = vec3( 1.0 );\r\n\r\n\t\t\t\treturn mix( checkColor, gridColor, lines );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat angleBetween( vec3 a, vec3 b ) {\r\n\r\n\t\t\t\treturn acos( abs( dot( a, b ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec3 planeProject( vec3 norm, vec3 other ) {\r\n\r\n\t\t\t\tfloat d = dot( norm, other );\r\n\t\t\t\treturn normalize( other - norm * d );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec3 getBlendFactors( vec3 norm ) {\r\n\r\n\t\t\t\tvec3 xVec = vec3( 1.0, 0.0, 0.0 );\r\n\t\t\t\tvec3 yVec = vec3( 0.0, 1.0, 0.0 );\r\n\t\t\t\tvec3 zVec = vec3( 0.0, 0.0, 1.0 );\r\n\r\n\t\t\t\tvec3 projX = planeProject( xVec, norm );\r\n\t\t\t\tvec3 projY = planeProject( yVec, norm );\r\n\t\t\t\tvec3 projZ = planeProject( zVec, norm );\r\n\r\n\t\t\t\tfloat xAngle = max(\r\n\t\t\t\t\tangleBetween( xVec, projY ),\r\n\t\t\t\t\tangleBetween( xVec, projZ )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tfloat yAngle = max(\r\n\t\t\t\t\tangleBetween( yVec, projX ),\r\n\t\t\t\t\tangleBetween( yVec, projZ )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tfloat zAngle = max(\r\n\t\t\t\t\tangleBetween( zVec, projX ),\r\n\t\t\t\t\tangleBetween( zVec, projY )\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );\r\n\r\n\t\t\t}\r\n\t\t` ).replace(\r\n\t\t/#include <normal_fragment_maps>/,\r\n\t\tv =>\r\n\t\t/* glsl */`${v}\r\n\t\t\t\t#if CSG_GRID\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n\r\n\t\t\t\t\tfloat yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );\r\n\t\t\t\t\tfloat zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );\r\n\t\t\t\t\tfloat xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );\r\n\r\n\t\t\t\t\tvec3 factors = getBlendFactors( worldNormal );\r\n\t\t\t\t\tfactors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );\r\n\r\n\t\t\t\t\tfloat weight = factors.x + factors.y + factors.z;\r\n\t\t\t\t\tfactors /= weight;\r\n\r\n\t\t\t\t\tvec3 color =\r\n\t\t\t\t\t\tgetFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +\r\n\t\t\t\t\t\tgetFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +\r\n\t\t\t\t\t\tgetFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;\r\n\r\n\t\t\t\t\tdiffuseColor.rgb = color;\r\n\r\n\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\t`,\r\n\t);\r\n\r\n\treturn shader;\r\n\r\n}\r\n", "import { MeshPhongMaterial } from 'three';\r\nimport { csgGridShaderMixin } from './shaderUtils.js';\r\n\r\nexport class GridMaterial extends MeshPhongMaterial {\r\n\r\n\tget enableGrid() {\r\n\r\n\t\treturn Boolean( this._enableGrid );\r\n\r\n\t}\r\n\r\n\tset enableGrid( v ) {\r\n\r\n\t\tif ( this._enableGrid !== v ) {\r\n\r\n\t\t\tthis._enableGrid = v;\r\n\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.enableGrid = true;\r\n\r\n\t}\r\n\r\n\tonBeforeCompile( shader ) {\r\n\r\n\t\tcsgGridShaderMixin( shader );\r\n\t\tshader.defines.CSG_GRID = Number( this.enableGrid );\r\n\r\n\t}\r\n\r\n\tcustomProgramCacheKey() {\r\n\r\n\t\treturn this.enableGrid.toString();\r\n\r\n\t}\r\n\r\n}\r\n", "import { BufferAttribute, Color, MathUtils } from 'three';\r\n\r\nexport function getTriangleDefinitions( ...triangles ) {\r\n\r\n\tfunction getVectorDefinition( v ) {\r\n\r\n\t\treturn /* js */`new THREE.Vector3( ${ v.x }, ${ v.y }, ${ v.z } )`;\r\n\r\n\t}\r\n\r\n\treturn triangles.map( t => {\r\n\r\n\t\treturn /* js */`\r\nnew THREE.Triangle(\r\n\t${ getVectorDefinition( t.a ) },\r\n\t${ getVectorDefinition( t.b ) },\r\n\t${ getVectorDefinition( t.c ) },\r\n)\r\n\t\t`.trim();\r\n\r\n\t} );\r\n\r\n}\r\n\r\nexport function logTriangleDefinitions( ...triangles ) {\r\n\r\n\tconsole.log( getTriangleDefinitions( ...triangles ).join( ',\\n' ) );\r\n\r\n}\r\n\r\nexport function generateRandomTriangleColors( geometry ) {\r\n\r\n\tconst position = geometry.attributes.position;\r\n\tconst array = new Float32Array( position.count * 3 );\r\n\r\n\tconst color = new Color();\r\n\tfor ( let i = 0, l = array.length; i < l; i += 9 ) {\r\n\r\n\t\tcolor.setHSL(\r\n\t\t\tMath.random(),\r\n\t\t\tMathUtils.lerp( 0.5, 1.0, Math.random() ),\r\n\t\t\tMathUtils.lerp( 0.5, 0.75, Math.random() ),\r\n\t\t);\r\n\r\n\t\tarray[ i + 0 ] = color.r;\r\n\t\tarray[ i + 1 ] = color.g;\r\n\t\tarray[ i + 2 ] = color.b;\r\n\r\n\t\tarray[ i + 3 ] = color.r;\r\n\t\tarray[ i + 4 ] = color.g;\r\n\t\tarray[ i + 5 ] = color.b;\r\n\r\n\t\tarray[ i + 6 ] = color.r;\r\n\t\tarray[ i + 7 ] = color.g;\r\n\t\tarray[ i + 8 ] = color.b;\r\n\r\n\t}\r\n\r\n\tgeometry.setAttribute( 'color', new BufferAttribute( array, 3 ) );\r\n\r\n}\r\n", "import { Group, Mesh, LineSegments, LineBasicMaterial, MeshPhongMaterial, BufferGeometry, BufferAttribute } from 'three';\r\n\r\nexport class TriangleSetHelper extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this._mesh.material.color;\r\n\r\n\t}\r\n\r\n\tget side() {\r\n\r\n\t\treturn this._mesh.material.side;\r\n\r\n\t}\r\n\r\n\tset side( v ) {\r\n\r\n\t\tthis._mesh.material.side = v;\r\n\r\n\t}\r\n\r\n\tconstructor( triangles = [] ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tconst geometry = new BufferGeometry();\r\n\t\tconst lineGeom = new BufferGeometry();\r\n\t\tthis._mesh = new Mesh( geometry, new MeshPhongMaterial( {\r\n\t\t\tflatShading: true,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.25,\r\n\t\t\tdepthWrite: false,\r\n\t\t} ) );\r\n\t\tthis._lines = new LineSegments( lineGeom, new LineBasicMaterial() );\r\n\t\tthis._mesh.material.color = this._lines.material.color;\r\n\r\n\t\tthis._lines.frustumCulled = false;\r\n\t\tthis._mesh.frustumCulled = false;\r\n\r\n\t\tthis.add( this._lines, this._mesh );\r\n\r\n\t\tthis.setTriangles( triangles );\r\n\r\n\t}\r\n\r\n\tsetTriangles( triangles ) {\r\n\r\n\t\tconst triPositions = new Float32Array( 3 * 3 * triangles.length );\r\n\t\tconst linePositions = new Float32Array( 6 * 3 * triangles.length );\r\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst i9 = 9 * i;\r\n\t\t\tconst i18 = 18 * i;\r\n\t\t\tconst tri = triangles[ i ];\r\n\r\n\t\t\ttri.a.toArray( triPositions, i9 + 0 );\r\n\t\t\ttri.b.toArray( triPositions, i9 + 3 );\r\n\t\t\ttri.c.toArray( triPositions, i9 + 6 );\r\n\r\n\r\n\t\t\ttri.a.toArray( linePositions, i18 + 0 );\r\n\t\t\ttri.b.toArray( linePositions, i18 + 3 );\r\n\r\n\t\t\ttri.b.toArray( linePositions, i18 + 6 );\r\n\t\t\ttri.c.toArray( linePositions, i18 + 9 );\r\n\r\n\t\t\ttri.c.toArray( linePositions, i18 + 12 );\r\n\t\t\ttri.a.toArray( linePositions, i18 + 15 );\r\n\r\n\t\t}\r\n\r\n\t\tthis._mesh.geometry.dispose();\r\n\t\tthis._mesh.geometry.setAttribute( 'position', new BufferAttribute( triPositions, 3 ) );\r\n\r\n\t\tthis._lines.geometry.dispose();\r\n\t\tthis._lines.geometry.setAttribute( 'position', new BufferAttribute( linePositions, 3 ) );\r\n\r\n\t}\r\n\r\n}\r\n", "import { LineSegments } from 'three';\r\n\r\nexport class EdgesHelper extends LineSegments {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.material.color;\r\n\r\n\t}\r\n\r\n\tconstructor( edges = [] ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.frustumCulled = false;\r\n\t\tthis.setEdges( edges );\r\n\r\n\t}\r\n\r\n\tsetEdges( edges ) {\r\n\r\n\t\tconst { geometry } = this;\r\n\t\tconst points = edges.flatMap( e => [ e.start, e.end ] );\r\n\t\tgeometry.dispose();\r\n\t\tgeometry.setFromPoints( points );\r\n\r\n\t}\r\n\r\n}\r\n", "import { InstancedMesh, SphereGeometry, MeshBasicMaterial, Matrix4 } from 'three';\r\n\r\nconst _matrix = new Matrix4();\r\nexport class PointsHelper extends InstancedMesh {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.material.color;\r\n\r\n\t}\r\n\r\n\tconstructor( count = 1000, points = [] ) {\r\n\r\n\t\tsuper( new SphereGeometry( 0.025 ), new MeshBasicMaterial(), count );\r\n\t\tthis.frustumCulled = false;\r\n\t\tthis.setPoints( points );\r\n\r\n\t}\r\n\r\n\tsetPoints( points ) {\r\n\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst point = points[ i ];\r\n\t\t\t_matrix.makeTranslation( point.x, point.y, point.z );\r\n\t\t\tthis.setMatrixAt( i, _matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = points.length;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Line3, Triangle, Vector3, Plane, Ray } from 'three';\r\nimport { EdgesHelper } from './EdgesHelper.js';\r\nimport { getTriCount } from '../core/utils/geometryUtils.js';\r\nimport { toNormalizedRay } from '../core/utils/hashUtils.js';\r\n\r\nconst vertKeys = [ 'a', 'b', 'c' ];\r\nconst _tri1 = new Triangle();\r\nconst _tri2 = new Triangle();\r\nconst _center = new Vector3();\r\nconst _center2 = new Vector3();\r\nconst _projected = new Vector3();\r\nconst _projected2 = new Vector3();\r\nconst _projectedDir = new Vector3();\r\nconst _projectedDir2 = new Vector3();\r\nconst _edgeDir = new Vector3();\r\nconst _edgeDir2 = new Vector3();\r\nconst _vec = new Vector3();\r\nconst _vec2 = new Vector3();\r\nconst _finalPoint = new Vector3();\r\nconst _finalPoint2 = new Vector3();\r\nconst _plane = new Plane();\r\nconst _plane2 = new Plane();\r\nconst _centerPoint = new Vector3();\r\nconst _ray = new Ray();\r\nconst _edge = new Line3();\r\n\r\nfunction getTriangle( geometry, triIndex, target ) {\r\n\r\n\tconst i3 = 3 * triIndex;\r\n\tlet i0 = i3 + 0;\r\n\tlet i1 = i3 + 1;\r\n\tlet i2 = i3 + 2;\r\n\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = geometry.attributes.position;\r\n\tif ( indexAttr ) {\r\n\r\n\t\ti0 = indexAttr.getX( i0 );\r\n\t\ti1 = indexAttr.getX( i1 );\r\n\t\ti2 = indexAttr.getX( i2 );\r\n\r\n\t}\r\n\r\n\ttarget.a.fromBufferAttribute( posAttr, i0 );\r\n\ttarget.b.fromBufferAttribute( posAttr, i1 );\r\n\ttarget.c.fromBufferAttribute( posAttr, i2 );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nfunction getOverlapEdge( tri1, e1, tri2, e2, target ) {\r\n\r\n\t// get the two edges\r\n\tconst nextE_0 = ( e1 + 1 ) % 3;\r\n\tconst v0_1 = tri1[ vertKeys[ e1 ] ];\r\n\tconst v1_1 = tri1[ vertKeys[ nextE_0 ] ];\r\n\r\n\tconst nextE_1 = ( e2 + 1 ) % 3;\r\n\tconst v0_2 = tri2[ vertKeys[ e2 ] ];\r\n\tconst v1_2 = tri2[ vertKeys[ nextE_1 ] ];\r\n\r\n\t// get the ray defined by the edges\r\n\ttoNormalizedRay( v0_1, v1_1, _ray );\r\n\r\n\t// get the min and max stride across the rays\r\n\tlet d0_1 = _vec.subVectors( v0_1, _ray.origin ).dot( _ray.direction );\r\n\tlet d1_1 = _vec.subVectors( v1_1, _ray.origin ).dot( _ray.direction );\r\n\tif ( d0_1 > d1_1 ) [ d0_1, d1_1 ] = [ d1_1, d0_1 ];\r\n\r\n\tlet d0_2 = _vec.subVectors( v0_2, _ray.origin ).dot( _ray.direction );\r\n\tlet d1_2 = _vec.subVectors( v1_2, _ray.origin ).dot( _ray.direction );\r\n\tif ( d0_2 > d1_2 ) [ d0_2, d1_2 ] = [ d1_2, d0_2 ];\r\n\r\n\t// get the range of overlap\r\n\tconst final_0 = Math.max( d0_1, d0_2 );\r\n\tconst final_1 = Math.min( d1_1, d1_2 );\r\n\t_ray.at( final_0, target.start );\r\n\t_ray.at( final_1, target.end );\r\n\r\n}\r\n\r\n\r\nexport class HalfEdgeHelper extends EdgesHelper {\r\n\r\n\tconstructor( geometry = null, halfEdges = null ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.straightEdges = false;\r\n\t\tthis.displayDisconnectedEdges = false;\r\n\r\n\t\tif ( geometry && halfEdges ) {\r\n\r\n\t\t\tthis.setHalfEdges( geometry, halfEdges );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetHalfEdges( geometry, halfEdges ) {\r\n\r\n\t\tconst { straightEdges, displayDisconnectedEdges } = this;\r\n\t\tconst edges = [];\r\n\t\tconst offset = geometry.drawRange.start;\r\n\t\tlet triCount = getTriCount( geometry );\r\n\t\tif ( geometry.drawRange.count !== Infinity ) {\r\n\r\n\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( displayDisconnectedEdges ) {\r\n\r\n\t\t\tif ( halfEdges.unmatchedDisjointEdges ) {\r\n\r\n\t\t\t\thalfEdges\r\n\t\t\t\t\t.unmatchedDisjointEdges\r\n\t\t\t\t\t.forEach( ( { forward, reverse, ray } ) => {\r\n\r\n\t\t\t\t\t\t[ ...forward, ...reverse ]\r\n\t\t\t\t\t\t\t.forEach( ( { start, end } ) => {\r\n\r\n\t\t\t\t\t\t\t\tconst edge = new Line3();\r\n\t\t\t\t\t\t\t\tray.at( start, edge.start );\r\n\t\t\t\t\t\t\t\tray.at( end, edge.end );\r\n\t\t\t\t\t\t\t\tedges.push( edge );\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let triIndex = offset; triIndex < triCount; triIndex ++ ) {\r\n\r\n\t\t\t\t\tgetTriangle( geometry, triIndex, _tri1 );\r\n\t\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\t\t\tconst otherTriIndex = halfEdges.getSiblingTriangleIndex( triIndex, e );\r\n\t\t\t\t\t\tif ( otherTriIndex === - 1 ) {\r\n\r\n\t\t\t\t\t\t\tconst nextE = ( e + 1 ) % 3;\r\n\t\t\t\t\t\t\tconst v0 = _tri1[ vertKeys[ e ] ];\r\n\t\t\t\t\t\t\tconst v1 = _tri1[ vertKeys[ nextE ] ];\r\n\t\t\t\t\t\t\tconst edge = new Line3();\r\n\t\t\t\t\t\t\tedge.start.copy( v0 );\r\n\t\t\t\t\t\t\tedge.end.copy( v1 );\r\n\t\t\t\t\t\t\tedges.push( edge );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let triIndex = offset; triIndex < triCount; triIndex ++ ) {\r\n\r\n\t\t\t\tgetTriangle( geometry, triIndex, _tri1 );\r\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\t\tconst otherTriIndex = halfEdges.getSiblingTriangleIndex( triIndex, e );\r\n\t\t\t\t\tif ( otherTriIndex === - 1 ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// get other triangle\r\n\t\t\t\t\tgetTriangle( geometry, otherTriIndex, _tri2 );\r\n\r\n\t\t\t\t\t// get edge centers\r\n\t\t\t\t\tconst nextE = ( e + 1 ) % 3;\r\n\t\t\t\t\tconst v0 = _tri1[ vertKeys[ e ] ];\r\n\t\t\t\t\tconst v1 = _tri1[ vertKeys[ nextE ] ];\r\n\t\t\t\t\t_centerPoint.lerpVectors( v0, v1, 0.5 );\r\n\t\t\t\t\taddConnectionEdge( _tri1, _tri2, _centerPoint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( halfEdges.disjointConnections ) {\r\n\r\n\t\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\t\t\tconst disjointTriIndices = halfEdges.getDisjointSiblingTriangleIndices( triIndex, e );\r\n\t\t\t\t\t\tconst disjointEdgeIndices = halfEdges.getDisjointSiblingEdgeIndices( triIndex, e );\r\n\r\n\t\t\t\t\t\tfor ( let i = 0; i < disjointTriIndices.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst ti = disjointTriIndices[ i ];\r\n\t\t\t\t\t\t\tconst ei = disjointEdgeIndices[ i ];\r\n\r\n\t\t\t\t\t\t\t// get other triangle\r\n\t\t\t\t\t\t\tgetTriangle( geometry, ti, _tri2 );\r\n\r\n\t\t\t\t\t\t\tgetOverlapEdge( _tri1, e, _tri2, ei, _edge );\r\n\r\n\t\t\t\t\t\t\t_centerPoint.lerpVectors( _edge.start, _edge.end, 0.5 );\r\n\t\t\t\t\t\t\taddConnectionEdge( _tri1, _tri2, _centerPoint );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.setEdges( edges );\r\n\r\n\t\tfunction addConnectionEdge( tri1, tri2, centerPoint ) {\r\n\r\n\t\t\ttri1.getMidpoint( _center );\r\n\t\t\ttri2.getMidpoint( _center2 );\r\n\r\n\t\t\ttri1.getPlane( _plane );\r\n\t\t\ttri2.getPlane( _plane2 );\r\n\r\n\t\t\tconst edge = new Line3();\r\n\t\t\tedge.start.copy( _center );\r\n\r\n\t\t\tif ( straightEdges ) {\r\n\r\n\t\t\t\t// get the projected centers\r\n\t\t\t\t_plane.projectPoint( _center2, _projected );\r\n\t\t\t\t_plane2.projectPoint( _center, _projected2 );\r\n\r\n\t\t\t\t// get the directions so we can flip them if needed\r\n\t\t\t\t_projectedDir.subVectors( _projected, _center );\r\n\t\t\t\t_projectedDir2.subVectors( _projected2, _center2 );\r\n\r\n\t\t\t\t// get the directions so we can flip them if needed\r\n\t\t\t\t_edgeDir.subVectors( centerPoint, _center );\r\n\t\t\t\t_edgeDir2.subVectors( centerPoint, _center2 );\r\n\r\n\t\t\t\tif ( _projectedDir.dot( _edgeDir ) < 0 ) {\r\n\r\n\t\t\t\t\t_projectedDir.multiplyScalar( - 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _projectedDir2.dot( _edgeDir2 ) < 0 ) {\r\n\r\n\t\t\t\t\t_projectedDir2.multiplyScalar( - 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the new points after inversion\r\n\t\t\t\t_vec.addVectors( _center, _projectedDir );\r\n\t\t\t\t_vec2.addVectors( _center2, _projectedDir2 );\r\n\r\n\t\t\t\t// project the points onto the triangle edge. This would be better\r\n\t\t\t\t// if we clipped instead of chose the closest point\r\n\t\t\t\ttri1.closestPointToPoint( _vec, _finalPoint );\r\n\t\t\t\ttri2.closestPointToPoint( _vec2, _finalPoint2 );\r\n\r\n\t\t\t\tedge.end.lerpVectors( _finalPoint, _finalPoint2, 0.5 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tedge.end.copy( centerPoint );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tedges.push( edge );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\nimport { Triangle } from 'three';\r\nimport { getTriCount } from '../core/utils/geometryUtils.js';\r\n\r\n// https://stackoverflow.com/questions/1406029/how-to-calculate-the-volume-of-a-3d-mesh-object-the-surface-of-which-is-made-up\r\nconst _tri = new Triangle();\r\nconst _normal = new Vector3();\r\nconst _relPoint = new Vector3();\r\nexport function computeMeshVolume( mesh ) {\r\n\r\n\t// grab the matrix and the geometry\r\n\tlet geometry;\r\n\tlet matrix;\r\n\tif ( mesh.isBufferGeometry ) {\r\n\r\n\t\tgeometry = mesh;\r\n\t\tmatrix = null;\r\n\r\n\t} else {\r\n\r\n\t\tgeometry = mesh.geometry;\r\n\t\tmatrix = Math.abs( mesh.matrixWorld.determinant() - 1.0 ) < 1e-15 ? null : mesh.matrixWorld;\r\n\r\n\t}\r\n\r\n\t// determine the number of relevant draw range elements to use\r\n\tconst index = geometry.index;\r\n\tconst pos = geometry.attributes.position;\r\n\tconst drawRange = geometry.drawRange;\r\n\tconst triCount = Math.min( getTriCount( geometry ), drawRange.count / 3 );\r\n\r\n\t// get a point relative to the position of the geometry to avoid floating point error\r\n\t_tri.setFromAttributeAndIndices( pos, 0, 1, 2 );\r\n\tapplyMatrix4ToTri( _tri, matrix );\r\n\t_tri.getNormal( _normal );\r\n\t_tri.getMidpoint( _relPoint ).add( _normal );\r\n\r\n\t// iterate over all triangles\r\n\tlet volume = 0;\r\n\tconst startIndex = drawRange.start / 3;\r\n\tfor ( let i = startIndex, l = startIndex + triCount; i < l; i ++ ) {\r\n\r\n\t\tlet i0 = 3 * i + 0;\r\n\t\tlet i1 = 3 * i + 1;\r\n\t\tlet i2 = 3 * i + 2;\r\n\t\tif ( index ) {\r\n\r\n\t\t\ti0 = index.getX( i0 );\r\n\t\t\ti1 = index.getX( i1 );\r\n\t\t\ti2 = index.getX( i2 );\r\n\r\n\t\t}\r\n\r\n\t\t// get the triangle\r\n\t\t_tri.setFromAttributeAndIndices( pos, i0, i1, i2 );\r\n\t\tapplyMatrix4ToTri( _tri, matrix );\r\n\t\tsubVectorFromTri( _tri, _relPoint );\r\n\r\n\t\t// add the signed volume\r\n\t\tvolume += signedVolumeOfTriangle( _tri.a, _tri.b, _tri.c );\r\n\r\n\t}\r\n\r\n\treturn Math.abs( volume );\r\n\r\n}\r\n\r\nfunction signedVolumeOfTriangle( p1, p2, p3 ) {\r\n\r\n\tconst v321 = p3.x * p2.y * p1.z;\r\n\tconst v231 = p2.x * p3.y * p1.z;\r\n\tconst v312 = p3.x * p1.y * p2.z;\r\n\tconst v132 = p1.x * p3.y * p2.z;\r\n\tconst v213 = p2.x * p1.y * p3.z;\r\n\tconst v123 = p1.x * p2.y * p3.z;\r\n\treturn ( 1 / 6 ) * ( - v321 + v231 + v312 - v132 - v213 + v123 );\r\n\r\n}\r\n\r\nfunction subVectorFromTri( tri, pos ) {\r\n\r\n\ttri.a.sub( pos );\r\n\ttri.b.sub( pos );\r\n\ttri.c.sub( pos );\r\n\r\n}\r\n\r\nfunction applyMatrix4ToTri( tri, mat = null ) {\r\n\r\n\tif ( mat !== null ) {\r\n\r\n\t\ttri.a.applyMatrix4( mat );\r\n\t\ttri.b.applyMatrix4( mat );\r\n\t\ttri.c.applyMatrix4( mat );\r\n\r\n\t}\r\n\r\n}\r\n"],
  "mappings": "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",
  "names": ["EPSILON", "_ray", "_vec3", "_edge", "_matrix", "_tri", "l", "i3", "i0", "i1", "i2", "type", "a", "b", "_matrix", "_tri2", "_vec", "_vec2", "_plane", "_plane2", "_ray", "_edge", "_tri", "_normal"]
}
