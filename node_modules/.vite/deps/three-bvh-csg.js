import {
  ExtendedTriangle,
  MeshBVH
} from "./chunk-KOUGE6T3.js";
import {
  BufferAttribute,
  BufferGeometry,
  Color,
  DoubleSide,
  Group,
  InstancedMesh,
  Line3,
  LineBasicMaterial,
  LineSegments,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshPhongMaterial,
  Plane,
  Ray,
  SphereGeometry,
  Triangle,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-YM4YKUOR.js";
import "./chunk-G3PMV62Z.js";

// node_modules/three-bvh-csg/src/core/utils/hashUtils.js
var HASH_WIDTH = 1e-6;
var HASH_HALF_WIDTH = HASH_WIDTH * 0.5;
var HASH_MULTIPLIER = Math.pow(10, -Math.log10(HASH_WIDTH));
var HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;
function hashNumber(v) {
  return ~~(v * HASH_MULTIPLIER + HASH_ADDITION);
}
function hashVertex2(v) {
  return `${hashNumber(v.x)},${hashNumber(v.y)}`;
}
function hashVertex3(v) {
  return `${hashNumber(v.x)},${hashNumber(v.y)},${hashNumber(v.z)}`;
}
function hashVertex4(v) {
  return `${hashNumber(v.x)},${hashNumber(v.y)},${hashNumber(v.z)},${hashNumber(v.w)}`;
}
function toNormalizedRay(v0, v1, target) {
  target.direction.subVectors(v1, v0).normalize();
  const scalar = v0.dot(target.direction);
  target.origin.copy(v0).addScaledVector(target.direction, -scalar);
  return target;
}

// node_modules/three-bvh-csg/src/core/utils/geometryUtils.js
function areSharedArrayBuffersSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}
function convertToSharedArrayBuffer(array) {
  if (array.buffer instanceof SharedArrayBuffer) {
    return array;
  }
  const cons = array.constructor;
  const buffer = array.buffer;
  const sharedBuffer = new SharedArrayBuffer(buffer.byteLength);
  const uintArray = new Uint8Array(buffer);
  const sharedUintArray = new Uint8Array(sharedBuffer);
  sharedUintArray.set(uintArray, 0);
  return new cons(sharedBuffer);
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}

// node_modules/three-bvh-csg/src/core/utils/halfEdgeUtils.js
var DEGENERATE_EPSILON = 1e-8;
var _tempVec = new Vector3();
function toTriIndex(v) {
  return ~~(v / 3);
}
function toEdgeIndex(v) {
  return v % 3;
}
function sortEdgeFunc(a, b) {
  return a.start - b.start;
}
function getProjectedDistance(ray, vec) {
  return _tempVec.subVectors(vec, ray.origin).dot(ray.direction);
}
function matchEdges(forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON) {
  forward.sort(sortEdgeFunc);
  reverse.sort(sortEdgeFunc);
  for (let i = 0; i < forward.length; i++) {
    const e0 = forward[i];
    for (let o = 0; o < reverse.length; o++) {
      const e1 = reverse[o];
      if (e1.start > e0.end) {
      } else if (e0.end < e1.start || e1.end < e0.start) {
        continue;
      } else if (e0.start <= e1.start && e0.end >= e1.end) {
        if (!areDistancesDegenerate(e1.end, e0.end)) {
          forward.splice(i + 1, 0, {
            start: e1.end,
            end: e0.end,
            index: e0.index
          });
        }
        e0.end = e1.start;
        e1.start = 0;
        e1.end = 0;
      } else if (e0.start >= e1.start && e0.end <= e1.end) {
        if (!areDistancesDegenerate(e0.end, e1.end)) {
          reverse.splice(o + 1, 0, {
            start: e0.end,
            end: e1.end,
            index: e1.index
          });
        }
        e1.end = e0.start;
        e0.start = 0;
        e0.end = 0;
      } else if (e0.start <= e1.start && e0.end <= e1.end) {
        const tmp = e0.end;
        e0.end = e1.start;
        e1.start = tmp;
      } else if (e0.start >= e1.start && e0.end >= e1.end) {
        const tmp = e1.end;
        e1.end = e0.start;
        e0.start = tmp;
      } else {
        throw new Error();
      }
      if (!disjointConnectivityMap.has(e0.index)) {
        disjointConnectivityMap.set(e0.index, []);
      }
      if (!disjointConnectivityMap.has(e1.index)) {
        disjointConnectivityMap.set(e1.index, []);
      }
      disjointConnectivityMap.get(e0.index).push(e1.index);
      disjointConnectivityMap.get(e1.index).push(e0.index);
      if (isEdgeDegenerate(e1)) {
        reverse.splice(o, 1);
        o--;
      }
      if (isEdgeDegenerate(e0)) {
        forward.splice(i, 1);
        i--;
        break;
      }
    }
  }
  cleanUpEdgeSet(forward);
  cleanUpEdgeSet(reverse);
  function cleanUpEdgeSet(arr) {
    for (let i = 0; i < arr.length; i++) {
      if (isEdgeDegenerate(arr[i])) {
        arr.splice(i, 1);
        i--;
      }
    }
  }
  function areDistancesDegenerate(start, end) {
    return Math.abs(end - start) < eps;
  }
  function isEdgeDegenerate(e) {
    return Math.abs(e.end - e.start) < eps;
  }
}

// node_modules/three-bvh-csg/src/core/utils/RaySet.js
var DIST_EPSILON = 1e-5;
var ANGLE_EPSILON = 1e-4;
var RaySet = class {
  constructor() {
    this._rays = [];
  }
  addRay(ray) {
    this._rays.push(ray);
  }
  findClosestRay(ray) {
    const rays = this._rays;
    const inv = ray.clone();
    inv.direction.multiplyScalar(-1);
    let bestScore = Infinity;
    let bestRay = null;
    for (let i = 0, l = rays.length; i < l; i++) {
      const r = rays[i];
      if (skipRay(r, ray) && skipRay(r, inv)) {
        continue;
      }
      const rayScore = scoreRays(r, ray);
      const invScore = scoreRays(r, inv);
      const score = Math.min(rayScore, invScore);
      if (score < bestScore) {
        bestScore = score;
        bestRay = r;
      }
    }
    return bestRay;
    function skipRay(r0, r1) {
      const distOutOfThreshold = r0.origin.distanceTo(r1.origin) > DIST_EPSILON;
      const angleOutOfThreshold = r0.direction.angleTo(r1.direction) > ANGLE_EPSILON;
      return angleOutOfThreshold || distOutOfThreshold;
    }
    function scoreRays(r0, r1) {
      const originDistance = r0.origin.distanceTo(r1.origin);
      const angleDistance = r0.direction.angleTo(r1.direction);
      return originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;
    }
  }
};

// node_modules/three-bvh-csg/src/core/utils/computeDisjointEdges.js
var _v0 = new Vector3();
var _v1 = new Vector3();
var _ray = new Ray();
function computeDisjointEdges(geometry, unmatchedSet, eps) {
  const attributes = geometry.attributes;
  const indexAttr = geometry.index;
  const posAttr = attributes.position;
  const disjointConnectivityMap = /* @__PURE__ */ new Map();
  const fragmentMap = /* @__PURE__ */ new Map();
  const edges = Array.from(unmatchedSet);
  const rays = new RaySet();
  for (let i = 0, l = edges.length; i < l; i++) {
    const index = edges[i];
    const triIndex = toTriIndex(index);
    const edgeIndex = toEdgeIndex(index);
    let i0 = 3 * triIndex + edgeIndex;
    let i1 = 3 * triIndex + (edgeIndex + 1) % 3;
    if (indexAttr) {
      i0 = indexAttr.getX(i0);
      i1 = indexAttr.getX(i1);
    }
    _v0.fromBufferAttribute(posAttr, i0);
    _v1.fromBufferAttribute(posAttr, i1);
    toNormalizedRay(_v0, _v1, _ray);
    let info;
    let commonRay = rays.findClosestRay(_ray);
    if (commonRay === null) {
      commonRay = _ray.clone();
      rays.addRay(commonRay);
    }
    if (!fragmentMap.has(commonRay)) {
      fragmentMap.set(commonRay, {
        forward: [],
        reverse: [],
        ray: commonRay
      });
    }
    info = fragmentMap.get(commonRay);
    let start = getProjectedDistance(commonRay, _v0);
    let end = getProjectedDistance(commonRay, _v1);
    if (start > end) {
      [start, end] = [end, start];
    }
    if (_ray.direction.dot(commonRay.direction) < 0) {
      info.reverse.push({ start, end, index });
    } else {
      info.forward.push({ start, end, index });
    }
  }
  fragmentMap.forEach(({ forward, reverse }, ray) => {
    matchEdges(forward, reverse, disjointConnectivityMap, eps);
    if (forward.length === 0 && reverse.length === 0) {
      fragmentMap.delete(ray);
    }
  });
  return {
    disjointConnectivityMap,
    fragmentMap
  };
}

// node_modules/three-bvh-csg/src/core/HalfEdgeMap.js
var _vec2 = new Vector2();
var _vec3 = new Vector3();
var _vec4 = new Vector4();
var _hashes = ["", "", ""];
var HalfEdgeMap = class {
  constructor(geometry = null) {
    this.data = null;
    this.disjointConnections = null;
    this.unmatchedDisjointEdges = null;
    this.unmatchedEdges = -1;
    this.matchedEdges = -1;
    this.useDrawRange = true;
    this.useAllAttributes = false;
    this.matchDisjointEdges = false;
    this.degenerateEpsilon = 1e-8;
    if (geometry) {
      this.updateFrom(geometry);
    }
  }
  getSiblingTriangleIndex(triIndex, edgeIndex) {
    const otherIndex = this.data[triIndex * 3 + edgeIndex];
    return otherIndex === -1 ? -1 : ~~(otherIndex / 3);
  }
  getSiblingEdgeIndex(triIndex, edgeIndex) {
    const otherIndex = this.data[triIndex * 3 + edgeIndex];
    return otherIndex === -1 ? -1 : otherIndex % 3;
  }
  getDisjointSiblingTriangleIndices(triIndex, edgeIndex) {
    const index = triIndex * 3 + edgeIndex;
    const arr = this.disjointConnections.get(index);
    return arr ? arr.map((i) => ~~(i / 3)) : [];
  }
  getDisjointSiblingEdgeIndices(triIndex, edgeIndex) {
    const index = triIndex * 3 + edgeIndex;
    const arr = this.disjointConnections.get(index);
    return arr ? arr.map((i) => i % 3) : [];
  }
  isFullyConnected() {
    return this.unmatchedEdges === 0;
  }
  updateFrom(geometry) {
    const { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;
    const hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;
    const map = /* @__PURE__ */ new Map();
    const { attributes } = geometry;
    const attrKeys = useAllAttributes ? Object.keys(attributes) : null;
    const indexAttr = geometry.index;
    const posAttr = attributes.position;
    let triCount = getTriCount(geometry);
    const maxTriCount = triCount;
    let offset = 0;
    if (useDrawRange) {
      offset = geometry.drawRange.start;
      if (geometry.drawRange.count !== Infinity) {
        triCount = ~~(geometry.drawRange.count / 3);
      }
    }
    let data = this.data;
    if (!data || data.length < 3 * maxTriCount) {
      data = new Int32Array(3 * maxTriCount);
    }
    data.fill(-1);
    let matchedEdges = 0;
    let unmatchedSet = /* @__PURE__ */ new Set();
    for (let i = offset, l = triCount * 3 + offset; i < l; i += 3) {
      const i3 = i;
      for (let e = 0; e < 3; e++) {
        let i0 = i3 + e;
        if (indexAttr) {
          i0 = indexAttr.getX(i0);
        }
        _hashes[e] = hashFunction(i0);
      }
      for (let e = 0; e < 3; e++) {
        const nextE = (e + 1) % 3;
        const vh0 = _hashes[e];
        const vh1 = _hashes[nextE];
        const reverseHash = `${vh1}_${vh0}`;
        if (map.has(reverseHash)) {
          const index = i3 + e;
          const otherIndex = map.get(reverseHash);
          data[index] = otherIndex;
          data[otherIndex] = index;
          map.delete(reverseHash);
          matchedEdges += 2;
          unmatchedSet.delete(otherIndex);
        } else {
          const hash = `${vh0}_${vh1}`;
          const index = i3 + e;
          map.set(hash, index);
          unmatchedSet.add(index);
        }
      }
    }
    if (matchDisjointEdges) {
      const {
        fragmentMap,
        disjointConnectivityMap
      } = computeDisjointEdges(geometry, unmatchedSet, degenerateEpsilon);
      unmatchedSet.clear();
      fragmentMap.forEach(({ forward, reverse }) => {
        forward.forEach(({ index }) => unmatchedSet.add(index));
        reverse.forEach(({ index }) => unmatchedSet.add(index));
      });
      this.unmatchedDisjointEdges = fragmentMap;
      this.disjointConnections = disjointConnectivityMap;
      matchedEdges = triCount * 3 - unmatchedSet.size;
    }
    this.matchedEdges = matchedEdges;
    this.unmatchedEdges = unmatchedSet.size;
    this.data = data;
    function hashPositionAttribute(i) {
      _vec3.fromBufferAttribute(posAttr, i);
      return hashVertex3(_vec3);
    }
    function hashAllAttributes(i) {
      let result = "";
      for (let k = 0, l = attrKeys.length; k < l; k++) {
        const attr = attributes[attrKeys[k]];
        let str;
        switch (attr.itemSize) {
          case 1:
            str = hashNumber(attr.getX(i));
            break;
          case 2:
            str = hashVertex2(_vec2.fromBufferAttribute(attr, i));
            break;
          case 3:
            str = hashVertex3(_vec3.fromBufferAttribute(attr, i));
            break;
          case 4:
            str = hashVertex4(_vec4.fromBufferAttribute(attr, i));
            break;
        }
        if (result !== "") {
          result += "|";
        }
        result += str;
      }
      return result;
    }
  }
};

// node_modules/three-bvh-csg/src/core/Brush.js
var Brush = class extends Mesh {
  constructor(...args) {
    super(...args);
    this.isBrush = true;
    this._previousMatrix = new Matrix4();
    this._previousMatrix.elements.fill(0);
  }
  markUpdated() {
    this._previousMatrix.copy(this.matrix);
  }
  isDirty() {
    const { matrix, _previousMatrix } = this;
    const el1 = matrix.elements;
    const el2 = _previousMatrix.elements;
    for (let i = 0; i < 16; i++) {
      if (el1[i] !== el2[i]) {
        return true;
      }
    }
    return false;
  }
  prepareGeometry() {
    const geometry = this.geometry;
    const attributes = geometry.attributes;
    const useSharedArrayBuffer = areSharedArrayBuffersSupported();
    if (useSharedArrayBuffer) {
      for (const key in attributes) {
        const attribute = attributes[key];
        if (attribute.isInterleavedBufferAttribute) {
          throw new Error("Brush: InterleavedBufferAttributes are not supported.");
        }
        attribute.array = convertToSharedArrayBuffer(attribute.array);
      }
    }
    if (!geometry.boundsTree) {
      ensureIndex(geometry, { useSharedArrayBuffer });
      geometry.boundsTree = new MeshBVH(geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer });
    }
    if (!geometry.halfEdges) {
      geometry.halfEdges = new HalfEdgeMap(geometry);
    }
    if (!geometry.groupIndices) {
      const triCount = getTriCount(geometry);
      const array = new Uint16Array(triCount);
      const groups = geometry.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const { start, count } = groups[i];
        for (let g = start / 3, lg = (start + count) / 3; g < lg; g++) {
          array[g] = i;
        }
      }
      geometry.groupIndices = array;
    }
  }
  disposeCacheData() {
    const { geometry } = this;
    geometry.halfEdges = null;
    geometry.boundsTree = null;
    geometry.groupIndices = null;
  }
};

// node_modules/three-bvh-csg/src/core/utils/triangleUtils.js
var EPSILON = 1e-14;
var _AB = new Vector3();
var _AC = new Vector3();
var _CB = new Vector3();
function isTriDegenerate(tri, eps = EPSILON) {
  _AB.subVectors(tri.b, tri.a);
  _AC.subVectors(tri.c, tri.a);
  _CB.subVectors(tri.b, tri.c);
  const angle1 = _AB.angleTo(_AC);
  const angle2 = _AB.angleTo(_CB);
  const angle3 = Math.PI - angle1 - angle2;
  return Math.abs(angle1) < eps || Math.abs(angle2) < eps || Math.abs(angle3) < eps || tri.a.distanceToSquared(tri.b) < eps || tri.a.distanceToSquared(tri.c) < eps || tri.b.distanceToSquared(tri.c) < eps;
}

// node_modules/three-bvh-csg/src/core/TriangleSplitter.js
var EPSILON2 = 1e-10;
var COPLANAR_EPSILON = 1e-10;
var PARALLEL_EPSILON = 1e-10;
var _edge = new Line3();
var _foundEdge = new Line3();
var _vec = new Vector3();
var _triangleNormal = new Vector3();
var _planeNormal = new Vector3();
var _plane = new Plane();
var _splittingTriangle = new ExtendedTriangle();
var TrianglePool = class {
  constructor() {
    this._pool = [];
    this._index = 0;
  }
  getTriangle() {
    if (this._index >= this._pool.length) {
      this._pool.push(new Triangle());
    }
    return this._pool[this._index++];
  }
  clear() {
    this._index = 0;
  }
  reset() {
    this._pool.length = 0;
    this._index = 0;
  }
};
var TriangleSplitter = class {
  constructor() {
    this.trianglePool = new TrianglePool();
    this.triangles = [];
    this.normal = new Vector3();
    this.coplanarTriangleUsed = false;
  }
  // initialize the class with a triangle
  initialize(tri) {
    this.reset();
    const { triangles, trianglePool, normal } = this;
    if (Array.isArray(tri)) {
      for (let i = 0, l = tri.length; i < l; i++) {
        const t = tri[i];
        if (i === 0) {
          t.getNormal(normal);
        } else if (Math.abs(1 - t.getNormal(_vec).dot(normal)) > EPSILON2) {
          throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");
        }
        const poolTri = trianglePool.getTriangle();
        poolTri.copy(t);
        triangles.push(poolTri);
      }
    } else {
      tri.getNormal(normal);
      const poolTri = trianglePool.getTriangle();
      poolTri.copy(tri);
      triangles.push(poolTri);
    }
  }
  // Split the current set of triangles by passing a single triangle in. If the triangle is
  // coplanar it will attempt to split by the triangle edge planes
  splitByTriangle(triangle) {
    const { normal, triangles } = this;
    triangle.getNormal(_triangleNormal).normalize();
    if (Math.abs(1 - Math.abs(_triangleNormal.dot(normal))) < PARALLEL_EPSILON) {
      this.coplanarTriangleUsed = true;
      for (let i = 0, l = triangles.length; i < l; i++) {
        const t = triangles[i];
        t.coplanarCount = 0;
      }
      const arr = [triangle.a, triangle.b, triangle.c];
      for (let i = 0; i < 3; i++) {
        const nexti = (i + 1) % 3;
        const v0 = arr[i];
        const v1 = arr[nexti];
        _vec.subVectors(v1, v0).normalize();
        _planeNormal.crossVectors(_triangleNormal, _vec);
        _plane.setFromNormalAndCoplanarPoint(_planeNormal, v0);
        this.splitByPlane(_plane, triangle);
      }
    } else {
      triangle.getPlane(_plane);
      this.splitByPlane(_plane, triangle);
    }
  }
  // Split the triangles by the given plan. If a triangle is provided then we ensure we
  // intersect the triangle before splitting the plane
  splitByPlane(plane, clippingTriangle) {
    const { triangles, trianglePool } = this;
    _splittingTriangle.copy(clippingTriangle);
    _splittingTriangle.needsUpdate = true;
    for (let i = 0, l = triangles.length; i < l; i++) {
      const tri = triangles[i];
      if (!_splittingTriangle.intersectsTriangle(tri, _edge, true)) {
        continue;
      }
      const { a, b, c } = tri;
      let intersects = 0;
      let vertexSplitEnd = -1;
      let coplanarEdge = false;
      let posSideVerts = [];
      let negSideVerts = [];
      const arr = [a, b, c];
      for (let t = 0; t < 3; t++) {
        const tNext = (t + 1) % 3;
        _edge.start.copy(arr[t]);
        _edge.end.copy(arr[tNext]);
        const startDist = plane.distanceToPoint(_edge.start);
        const endDist = plane.distanceToPoint(_edge.end);
        if (Math.abs(startDist) < COPLANAR_EPSILON && Math.abs(endDist) < COPLANAR_EPSILON) {
          coplanarEdge = true;
          break;
        }
        if (startDist > 0) {
          posSideVerts.push(t);
        } else {
          negSideVerts.push(t);
        }
        if (Math.abs(startDist) < COPLANAR_EPSILON) {
          continue;
        }
        let didIntersect = !!plane.intersectLine(_edge, _vec);
        if (!didIntersect && Math.abs(endDist) < COPLANAR_EPSILON) {
          _vec.copy(_edge.end);
          didIntersect = true;
        }
        if (didIntersect && !(_vec.distanceTo(_edge.start) < EPSILON2)) {
          if (_vec.distanceTo(_edge.end) < EPSILON2) {
            vertexSplitEnd = t;
          }
          if (intersects === 0) {
            _foundEdge.start.copy(_vec);
          } else {
            _foundEdge.end.copy(_vec);
          }
          intersects++;
        }
      }
      if (!coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON) {
        if (vertexSplitEnd !== -1) {
          vertexSplitEnd = (vertexSplitEnd + 1) % 3;
          let otherVert1 = 0;
          if (otherVert1 === vertexSplitEnd) {
            otherVert1 = (otherVert1 + 1) % 3;
          }
          let otherVert2 = otherVert1 + 1;
          if (otherVert2 === vertexSplitEnd) {
            otherVert2 = (otherVert2 + 1) % 3;
          }
          const nextTri = trianglePool.getTriangle();
          nextTri.a.copy(arr[otherVert2]);
          nextTri.b.copy(_foundEdge.end);
          nextTri.c.copy(_foundEdge.start);
          if (!isTriDegenerate(nextTri)) {
            triangles.push(nextTri);
          }
          tri.a.copy(arr[otherVert1]);
          tri.b.copy(_foundEdge.start);
          tri.c.copy(_foundEdge.end);
          if (isTriDegenerate(tri)) {
            triangles.splice(i, 1);
            i--;
            l--;
          }
        } else {
          const singleVert = posSideVerts.length >= 2 ? negSideVerts[0] : posSideVerts[0];
          if (singleVert === 0) {
            let tmp = _foundEdge.start;
            _foundEdge.start = _foundEdge.end;
            _foundEdge.end = tmp;
          }
          const nextVert1 = (singleVert + 1) % 3;
          const nextVert2 = (singleVert + 2) % 3;
          const nextTri1 = trianglePool.getTriangle();
          const nextTri2 = trianglePool.getTriangle();
          if (arr[nextVert1].distanceToSquared(_foundEdge.start) < arr[nextVert2].distanceToSquared(_foundEdge.end)) {
            nextTri1.a.copy(arr[nextVert1]);
            nextTri1.b.copy(_foundEdge.start);
            nextTri1.c.copy(_foundEdge.end);
            nextTri2.a.copy(arr[nextVert1]);
            nextTri2.b.copy(arr[nextVert2]);
            nextTri2.c.copy(_foundEdge.start);
          } else {
            nextTri1.a.copy(arr[nextVert2]);
            nextTri1.b.copy(_foundEdge.start);
            nextTri1.c.copy(_foundEdge.end);
            nextTri2.a.copy(arr[nextVert1]);
            nextTri2.b.copy(arr[nextVert2]);
            nextTri2.c.copy(_foundEdge.end);
          }
          tri.a.copy(arr[singleVert]);
          tri.b.copy(_foundEdge.end);
          tri.c.copy(_foundEdge.start);
          if (!isTriDegenerate(nextTri1)) {
            triangles.push(nextTri1);
          }
          if (!isTriDegenerate(nextTri2)) {
            triangles.push(nextTri2);
          }
          if (isTriDegenerate(tri)) {
            triangles.splice(i, 1);
            i--;
            l--;
          }
        }
      } else if (intersects === 3) {
        console.warn("TriangleClipper: Coplanar clip not handled");
      }
    }
  }
  reset() {
    this.triangles.length = 0;
    this.trianglePool.clear();
    this.coplanarTriangleUsed = false;
  }
};

// node_modules/three-bvh-csg/src/core/TypeBackedArray.js
function ceilToFourByteStride(byteLength) {
  byteLength = ~~byteLength;
  return byteLength + 4 - byteLength % 4;
}
var TypeBackedArray = class {
  constructor(type, initialSize = 500) {
    this.expansionFactor = 1.5;
    this.type = type;
    this.length = 0;
    this.array = null;
    this.setSize(initialSize);
  }
  setType(type) {
    if (this.length !== 0) {
      throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");
    }
    const buffer = this.array.buffer;
    this.array = new type(buffer);
    this.type = type;
  }
  setSize(size) {
    if (this.array && size === this.array.length) {
      return;
    }
    const type = this.type;
    const bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;
    const newArray = new type(new bufferType(ceilToFourByteStride(size * type.BYTES_PER_ELEMENT)));
    if (this.array) {
      newArray.set(this.array, 0);
    }
    this.array = newArray;
  }
  expand() {
    const { array, expansionFactor } = this;
    this.setSize(array.length * expansionFactor);
  }
  push(...args) {
    let { array, length } = this;
    if (length + args.length > array.length) {
      this.expand();
      array = this.array;
    }
    for (let i = 0, l = args.length; i < l; i++) {
      array[length + i] = args[i];
    }
    this.length += args.length;
  }
  clear() {
    this.length = 0;
  }
};

// node_modules/three-bvh-csg/src/core/TypedAttributeData.js
var TypedAttributeData = class {
  constructor() {
    this.groupAttributes = [{}];
    this.groupCount = 0;
  }
  // returns the buffer type for the given attribute
  getType(name) {
    return this.groupAttributes[0][name].type;
  }
  getItemSize(name) {
    return this.groupAttributes[0][name].itemSize;
  }
  getNormalized(name) {
    return this.groupAttributes[0][name].normalized;
  }
  getCount(index) {
    if (this.groupCount <= index) {
      return 0;
    }
    const pos = this.getGroupAttrArray("position", index);
    return pos.length / pos.itemSize;
  }
  // returns the total length required for all groups for the given attribute
  getTotalLength(name) {
    const { groupCount, groupAttributes } = this;
    let length = 0;
    for (let i = 0; i < groupCount; i++) {
      const attrSet = groupAttributes[i];
      length += attrSet[name].length;
    }
    return length;
  }
  getGroupAttrSet(index = 0) {
    const { groupAttributes } = this;
    if (groupAttributes[index]) {
      this.groupCount = Math.max(this.groupCount, index + 1);
      return groupAttributes[index];
    }
    const refAttrSet = groupAttributes[0];
    this.groupCount = Math.max(this.groupCount, index + 1);
    while (index >= groupAttributes.length) {
      const newAttrSet = {};
      groupAttributes.push(newAttrSet);
      for (const key in refAttrSet) {
        const refAttr = refAttrSet[key];
        const newAttr = new TypeBackedArray(refAttr.type);
        newAttr.itemSize = refAttr.itemSize;
        newAttr.normalized = refAttr.normalized;
        newAttrSet[key] = newAttr;
      }
    }
    return groupAttributes[index];
  }
  // Get the raw array for the group set of data
  getGroupAttrArray(name, index = 0) {
    const { groupAttributes } = this;
    const referenceAttrSet = groupAttributes[0];
    const referenceAttr = referenceAttrSet[name];
    if (!referenceAttr) {
      throw new Error(`TypedAttributeData: Attribute with "${name}" has not been initialized`);
    }
    return this.getGroupAttrSet(index)[name];
  }
  // initializes an attribute array with the given name, type, and size
  initializeArray(name, type, itemSize, normalized) {
    const { groupAttributes } = this;
    const referenceAttrSet = groupAttributes[0];
    const referenceAttr = referenceAttrSet[name];
    if (referenceAttr) {
      if (referenceAttr.type !== type) {
        for (let i = 0, l = groupAttributes.length; i < l; i++) {
          const arr = groupAttributes[i][name];
          arr.setType(type);
          arr.itemSize = itemSize;
          arr.normalized = normalized;
        }
      }
    } else {
      for (let i = 0, l = groupAttributes.length; i < l; i++) {
        const arr = new TypeBackedArray(type);
        arr.itemSize = itemSize;
        arr.normalized = normalized;
        groupAttributes[i][name] = arr;
      }
    }
  }
  // Clear all the data
  clear() {
    this.groupCount = 0;
    const { groupAttributes } = this;
    groupAttributes.forEach((attrSet) => {
      for (const key in attrSet) {
        attrSet[key].clear();
      }
    });
  }
  // Remove the given key
  delete(key) {
    this.groupAttributes.forEach((attrSet) => {
      delete attrSet[key];
    });
  }
  // Reset the datasets completely
  reset() {
    this.groupAttributes = [];
    this.groupCount = 0;
  }
};

// node_modules/three-bvh-csg/src/core/IntersectionMap.js
var IntersectionMap = class {
  constructor() {
    this.intersectionSet = {};
    this.ids = [];
  }
  add(id, intersectionId) {
    const { intersectionSet, ids } = this;
    if (!intersectionSet[id]) {
      intersectionSet[id] = [];
      ids.push(id);
    }
    intersectionSet[id].push(intersectionId);
  }
};

// node_modules/three-bvh-csg/src/core/constants.js
var ADDITION = 0;
var SUBTRACTION = 1;
var REVERSE_SUBTRACTION = 2;
var INTERSECTION = 3;
var DIFFERENCE = 4;
var HOLLOW_SUBTRACTION = 5;
var HOLLOW_INTERSECTION = 6;

// node_modules/three-bvh-csg/src/core/operations/operationsUtils.js
var _ray2 = new Ray();
var _matrix = new Matrix4();
var _tri = new Triangle();
var _vec32 = new Vector3();
var _vec4a = new Vector4();
var _vec4b = new Vector4();
var _vec4c = new Vector4();
var _vec4_0 = new Vector4();
var _vec4_1 = new Vector4();
var _vec4_2 = new Vector4();
var _edge2 = new Line3();
var _normal = new Vector3();
var JITTER_EPSILON = 1e-8;
var OFFSET_EPSILON = 1e-15;
var BACK_SIDE = -1;
var FRONT_SIDE = 1;
var COPLANAR_OPPOSITE = -2;
var COPLANAR_ALIGNED = 2;
var INVERT_TRI = 0;
var ADD_TRI = 1;
var SKIP_TRI = 2;
var FLOATING_COPLANAR_EPSILON = 1e-14;
var _debugContext = null;
function setDebugContext(debugData) {
  _debugContext = debugData;
}
function getHitSide(tri, bvh) {
  tri.getMidpoint(_ray2.origin);
  tri.getNormal(_ray2.direction);
  const hit = bvh.raycastFirst(_ray2, DoubleSide);
  const hitBackSide = Boolean(hit && _ray2.direction.dot(hit.face.normal) > 0);
  return hitBackSide ? BACK_SIDE : FRONT_SIDE;
}
function getHitSideWithCoplanarCheck(tri, bvh) {
  function rand() {
    return Math.random() - 0.5;
  }
  tri.getNormal(_normal);
  _ray2.direction.copy(_normal);
  tri.getMidpoint(_ray2.origin);
  const total = 3;
  let count = 0;
  let minDistance = Infinity;
  for (let i = 0; i < total; i++) {
    _ray2.direction.x += rand() * JITTER_EPSILON;
    _ray2.direction.y += rand() * JITTER_EPSILON;
    _ray2.direction.z += rand() * JITTER_EPSILON;
    _ray2.direction.multiplyScalar(-1);
    const hit = bvh.raycastFirst(_ray2, DoubleSide);
    let hitBackSide = Boolean(hit && _ray2.direction.dot(hit.face.normal) > 0);
    if (hitBackSide) {
      count++;
    }
    if (hit !== null) {
      minDistance = Math.min(minDistance, hit.distance);
    }
    if (minDistance <= OFFSET_EPSILON) {
      return hit.face.normal.dot(_normal) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;
    }
    if (count / total > 0.5 || (i - count + 1) / total > 0.5) {
      break;
    }
  }
  return count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;
}
function collectIntersectingTriangles(a, b) {
  const aIntersections = new IntersectionMap();
  const bIntersections = new IntersectionMap();
  _matrix.copy(a.matrixWorld).invert().multiply(b.matrixWorld);
  a.geometry.boundsTree.bvhcast(b.geometry.boundsTree, _matrix, {
    intersectsTriangles(triangleA, triangleB, ia, ib) {
      if (!isTriDegenerate(triangleA) && !isTriDegenerate(triangleB)) {
        let intersected = triangleA.intersectsTriangle(triangleB, _edge2, true);
        if (!intersected) {
          const pa = triangleA.plane;
          const pb = triangleB.plane;
          const na = pa.normal;
          const nb = pb.normal;
          if (na.dot(nb) === 1 && Math.abs(pa.constant - pb.constant) < FLOATING_COPLANAR_EPSILON) {
            intersected = true;
          }
        }
        if (intersected) {
          let va = a.geometry.boundsTree.resolveTriangleIndex(ia);
          let vb = b.geometry.boundsTree.resolveTriangleIndex(ib);
          aIntersections.add(va, vb);
          bIntersections.add(vb, va);
          if (_debugContext) {
            _debugContext.addEdge(_edge2);
            _debugContext.addIntersectingTriangles(ia, triangleA, ib, triangleB);
          }
        }
      }
      return false;
    }
  });
  return { aIntersections, bIntersections };
}
function appendAttributeFromTriangle(triIndex, baryCoordTri, geometry, matrixWorld, normalMatrix, attributeData, invert = false) {
  const attributes = geometry.attributes;
  const indexAttr = geometry.index;
  const i3 = triIndex * 3;
  const i0 = indexAttr.getX(i3 + 0);
  const i1 = indexAttr.getX(i3 + 1);
  const i2 = indexAttr.getX(i3 + 2);
  for (const key in attributeData) {
    const attr = attributes[key];
    const arr = attributeData[key];
    if (!(key in attributes)) {
      throw new Error(`CSG Operations: Attribute ${key} not available on geometry.`);
    }
    const itemSize = attr.itemSize;
    if (key === "position") {
      _tri.a.fromBufferAttribute(attr, i0).applyMatrix4(matrixWorld);
      _tri.b.fromBufferAttribute(attr, i1).applyMatrix4(matrixWorld);
      _tri.c.fromBufferAttribute(attr, i2).applyMatrix4(matrixWorld);
      pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert);
    } else if (key === "normal") {
      _tri.a.fromBufferAttribute(attr, i0).applyNormalMatrix(normalMatrix);
      _tri.b.fromBufferAttribute(attr, i1).applyNormalMatrix(normalMatrix);
      _tri.c.fromBufferAttribute(attr, i2).applyNormalMatrix(normalMatrix);
      if (invert) {
        _tri.a.multiplyScalar(-1);
        _tri.b.multiplyScalar(-1);
        _tri.c.multiplyScalar(-1);
      }
      pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true);
    } else {
      _vec4a.fromBufferAttribute(attr, i0);
      _vec4b.fromBufferAttribute(attr, i1);
      _vec4c.fromBufferAttribute(attr, i2);
      pushBarycoordInterpolatedValues(_vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert);
    }
  }
}
function appendAttributesFromIndices(i0, i1, i2, attributes, matrixWorld, normalMatrix, attributeData, invert = false) {
  appendAttributeFromIndex(i0, attributes, matrixWorld, normalMatrix, attributeData, invert);
  appendAttributeFromIndex(invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert);
  appendAttributeFromIndex(invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert);
}
function getOperationAction(operation, hitSide, invert = false) {
  switch (operation) {
    case ADDITION:
      if (hitSide === FRONT_SIDE || hitSide === COPLANAR_ALIGNED && !invert) {
        return ADD_TRI;
      }
      break;
    case SUBTRACTION:
      if (invert) {
        if (hitSide === BACK_SIDE) {
          return INVERT_TRI;
        }
      } else {
        if (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE) {
          return ADD_TRI;
        }
      }
      break;
    case REVERSE_SUBTRACTION:
      if (invert) {
        if (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE) {
          return ADD_TRI;
        }
      } else {
        if (hitSide === BACK_SIDE) {
          return INVERT_TRI;
        }
      }
      break;
    case DIFFERENCE:
      if (hitSide === BACK_SIDE) {
        return INVERT_TRI;
      } else if (hitSide === FRONT_SIDE) {
        return ADD_TRI;
      }
      break;
    case INTERSECTION:
      if (hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED && !invert) {
        return ADD_TRI;
      }
      break;
    case HOLLOW_SUBTRACTION:
      if (!invert && (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE)) {
        return ADD_TRI;
      }
      break;
    case HOLLOW_INTERSECTION:
      if (!invert && (hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED)) {
        return ADD_TRI;
      }
      break;
    default:
      throw new Error(`Unrecognized CSG operation enum "${operation}".`);
  }
  return SKIP_TRI;
}
function pushBarycoordInterpolatedValues(v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false) {
  const addValues = (v) => {
    attrArr.push(v.x);
    if (itemSize > 1) attrArr.push(v.y);
    if (itemSize > 2) attrArr.push(v.z);
    if (itemSize > 3) attrArr.push(v.w);
  };
  _vec4_0.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.a.x).addScaledVector(v1, baryCoordTri.a.y).addScaledVector(v2, baryCoordTri.a.z);
  _vec4_1.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.b.x).addScaledVector(v1, baryCoordTri.b.y).addScaledVector(v2, baryCoordTri.b.z);
  _vec4_2.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.c.x).addScaledVector(v1, baryCoordTri.c.y).addScaledVector(v2, baryCoordTri.c.z);
  if (normalize) {
    _vec4_0.normalize();
    _vec4_1.normalize();
    _vec4_2.normalize();
  }
  addValues(_vec4_0);
  if (invert) {
    addValues(_vec4_2);
    addValues(_vec4_1);
  } else {
    addValues(_vec4_1);
    addValues(_vec4_2);
  }
}
function appendAttributeFromIndex(index, attributes, matrixWorld, normalMatrix, attributeData, invert = false) {
  for (const key in attributeData) {
    const attr = attributes[key];
    const arr = attributeData[key];
    if (!(key in attributes)) {
      throw new Error(`CSG Operations: Attribute ${key} no available on geometry.`);
    }
    const itemSize = attr.itemSize;
    if (key === "position") {
      _vec32.fromBufferAttribute(attr, index).applyMatrix4(matrixWorld);
      arr.push(_vec32.x, _vec32.y, _vec32.z);
    } else if (key === "normal") {
      _vec32.fromBufferAttribute(attr, index).applyNormalMatrix(normalMatrix);
      if (invert) {
        _vec32.multiplyScalar(-1);
      }
      arr.push(_vec32.x, _vec32.y, _vec32.z);
    } else {
      arr.push(attr.getX(index));
      if (itemSize > 1) arr.push(attr.getY(index));
      if (itemSize > 2) arr.push(attr.getZ(index));
      if (itemSize > 3) arr.push(attr.getW(index));
    }
  }
}

// node_modules/three-bvh-csg/src/core/debug/OperationDebugData.js
var TriangleIntersectData = class {
  constructor(tri) {
    this.triangle = new Triangle().copy(tri);
    this.intersects = {};
  }
  addTriangle(index, tri) {
    this.intersects[index] = new Triangle().copy(tri);
  }
  getIntersectArray() {
    const array = [];
    const { intersects } = this;
    for (const key in intersects) {
      array.push(intersects[key]);
    }
    return array;
  }
};
var TriangleIntersectionSets = class {
  constructor() {
    this.data = {};
  }
  addTriangleIntersection(ia, triA, ib, triB) {
    const { data } = this;
    if (!data[ia]) {
      data[ia] = new TriangleIntersectData(triA);
    }
    data[ia].addTriangle(ib, triB);
  }
  getTrianglesAsArray(id = null) {
    const { data } = this;
    const arr = [];
    if (id !== null) {
      if (id in data) {
        arr.push(data[id].triangle);
      }
    } else {
      for (const key in data) {
        arr.push(data[key].triangle);
      }
    }
    return arr;
  }
  getTriangleIndices() {
    return Object.keys(this.data).map((i) => parseInt(i));
  }
  getIntersectionIndices(id) {
    const { data } = this;
    if (!data[id]) {
      return [];
    } else {
      return Object.keys(data[id].intersects).map((i) => parseInt(i));
    }
  }
  getIntersectionsAsArray(id = null, id2 = null) {
    const { data } = this;
    const triSet = /* @__PURE__ */ new Set();
    const arr = [];
    const addTriangles = (key) => {
      if (!data[key]) return;
      if (id2 !== null) {
        if (data[key].intersects[id2]) {
          arr.push(data[key].intersects[id2]);
        }
      } else {
        const intersects = data[key].intersects;
        for (const key2 in intersects) {
          if (!triSet.has(key2)) {
            triSet.add(key2);
            arr.push(intersects[key2]);
          }
        }
      }
    };
    if (id !== null) {
      addTriangles(id);
    } else {
      for (const key in data) {
        addTriangles(key);
      }
    }
    return arr;
  }
  reset() {
    this.data = {};
  }
};
var OperationDebugData = class {
  constructor() {
    this.enabled = false;
    this.triangleIntersectsA = new TriangleIntersectionSets();
    this.triangleIntersectsB = new TriangleIntersectionSets();
    this.intersectionEdges = [];
  }
  addIntersectingTriangles(ia, triA, ib, triB) {
    const { triangleIntersectsA, triangleIntersectsB } = this;
    triangleIntersectsA.addTriangleIntersection(ia, triA, ib, triB);
    triangleIntersectsB.addTriangleIntersection(ib, triB, ia, triA);
  }
  addEdge(edge) {
    this.intersectionEdges.push(edge.clone());
  }
  reset() {
    this.triangleIntersectsA.reset();
    this.triangleIntersectsB.reset();
    this.intersectionEdges = [];
  }
  init() {
    if (this.enabled) {
      this.reset();
      setDebugContext(this);
    }
  }
  complete() {
    if (this.enabled) {
      setDebugContext(null);
    }
  }
};

// node_modules/three-bvh-csg/src/core/operations/operations.js
var _matrix2 = new Matrix4();
var _normalMatrix = new Matrix3();
var _triA = new Triangle();
var _triB = new Triangle();
var _tri2 = new Triangle();
var _barycoordTri = new Triangle();
var _attr = [];
var _actions = [];
function getFirstIdFromSet(set) {
  for (const id of set) return id;
}
function performOperation(a, b, operations, splitter, attributeData, options = {}) {
  const { useGroups = true } = options;
  const { aIntersections, bIntersections } = collectIntersectingTriangles(a, b);
  const resultGroups = [];
  let resultMaterials = null;
  let groupOffset;
  groupOffset = useGroups ? 0 : -1;
  performSplitTriangleOperations(a, b, aIntersections, operations, false, splitter, attributeData, groupOffset);
  performWholeTriangleOperations(a, b, aIntersections, operations, false, attributeData, groupOffset);
  const nonHollow = operations.findIndex((op) => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION) !== -1;
  if (nonHollow) {
    groupOffset = useGroups ? a.geometry.groups.length || 1 : -1;
    performSplitTriangleOperations(b, a, bIntersections, operations, true, splitter, attributeData, groupOffset);
    performWholeTriangleOperations(b, a, bIntersections, operations, true, attributeData, groupOffset);
  }
  _attr.length = 0;
  _actions.length = 0;
  return {
    groups: resultGroups,
    materials: resultMaterials
  };
}
function performSplitTriangleOperations(a, b, intersectionMap, operations, invert, splitter, attributeData, groupOffset = 0) {
  const invertedGeometry = a.matrixWorld.determinant() < 0;
  _matrix2.copy(b.matrixWorld).invert().multiply(a.matrixWorld);
  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);
  const groupIndices = a.geometry.groupIndices;
  const aIndex = a.geometry.index;
  const aPosition = a.geometry.attributes.position;
  const bBVH = b.geometry.boundsTree;
  const bIndex = b.geometry.index;
  const bPosition = b.geometry.attributes.position;
  const splitIds = intersectionMap.ids;
  const intersectionSet = intersectionMap.intersectionSet;
  for (let i = 0, l = splitIds.length; i < l; i++) {
    const ia = splitIds[i];
    const groupIndex = groupOffset === -1 ? 0 : groupIndices[ia] + groupOffset;
    const ia3 = 3 * ia;
    const ia0 = aIndex.getX(ia3 + 0);
    const ia1 = aIndex.getX(ia3 + 1);
    const ia2 = aIndex.getX(ia3 + 2);
    _triA.a.fromBufferAttribute(aPosition, ia0).applyMatrix4(_matrix2);
    _triA.b.fromBufferAttribute(aPosition, ia1).applyMatrix4(_matrix2);
    _triA.c.fromBufferAttribute(aPosition, ia2).applyMatrix4(_matrix2);
    splitter.reset();
    splitter.initialize(_triA);
    const intersectingIndices = intersectionSet[ia];
    for (let ib = 0, l2 = intersectingIndices.length; ib < l2; ib++) {
      const ib3 = 3 * intersectingIndices[ib];
      const ib0 = bIndex.getX(ib3 + 0);
      const ib1 = bIndex.getX(ib3 + 1);
      const ib2 = bIndex.getX(ib3 + 2);
      _triB.a.fromBufferAttribute(bPosition, ib0);
      _triB.b.fromBufferAttribute(bPosition, ib1);
      _triB.c.fromBufferAttribute(bPosition, ib2);
      splitter.splitByTriangle(_triB);
    }
    const triangles = splitter.triangles;
    for (let ib = 0, l2 = triangles.length; ib < l2; ib++) {
      const clippedTri = triangles[ib];
      const hitSide = splitter.coplanarTriangleUsed ? getHitSideWithCoplanarCheck(clippedTri, bBVH) : getHitSide(clippedTri, bBVH);
      _attr.length = 0;
      _actions.length = 0;
      for (let o = 0, lo = operations.length; o < lo; o++) {
        const op = getOperationAction(operations[o], hitSide, invert);
        if (op !== SKIP_TRI) {
          _actions.push(op);
          _attr.push(attributeData[o].getGroupAttrSet(groupIndex));
        }
      }
      if (_attr.length !== 0) {
        _triA.getBarycoord(clippedTri.a, _barycoordTri.a);
        _triA.getBarycoord(clippedTri.b, _barycoordTri.b);
        _triA.getBarycoord(clippedTri.c, _barycoordTri.c);
        for (let k = 0, lk = _attr.length; k < lk; k++) {
          const attrSet = _attr[k];
          const action = _actions[k];
          const invertTri = action === INVERT_TRI;
          appendAttributeFromTriangle(ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri);
        }
      }
    }
  }
  return splitIds.length;
}
function performWholeTriangleOperations(a, b, splitTriSet, operations, invert, attributeData, groupOffset = 0) {
  const invertedGeometry = a.matrixWorld.determinant() < 0;
  _matrix2.copy(b.matrixWorld).invert().multiply(a.matrixWorld);
  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);
  const bBVH = b.geometry.boundsTree;
  const groupIndices = a.geometry.groupIndices;
  const aIndex = a.geometry.index;
  const aAttributes = a.geometry.attributes;
  const aPosition = aAttributes.position;
  const stack = [];
  const halfEdges = a.geometry.halfEdges;
  const traverseSet = /* @__PURE__ */ new Set();
  const triCount = getTriCount(a.geometry);
  for (let i = 0, l = triCount; i < l; i++) {
    if (!(i in splitTriSet.intersectionSet)) {
      traverseSet.add(i);
    }
  }
  while (traverseSet.size > 0) {
    const id = getFirstIdFromSet(traverseSet);
    traverseSet.delete(id);
    stack.push(id);
    const i3 = 3 * id;
    const i0 = aIndex.getX(i3 + 0);
    const i1 = aIndex.getX(i3 + 1);
    const i2 = aIndex.getX(i3 + 2);
    _tri2.a.fromBufferAttribute(aPosition, i0).applyMatrix4(_matrix2);
    _tri2.b.fromBufferAttribute(aPosition, i1).applyMatrix4(_matrix2);
    _tri2.c.fromBufferAttribute(aPosition, i2).applyMatrix4(_matrix2);
    const hitSide = getHitSide(_tri2, bBVH);
    _actions.length = 0;
    _attr.length = 0;
    for (let o = 0, lo = operations.length; o < lo; o++) {
      const op = getOperationAction(operations[o], hitSide, invert);
      if (op !== SKIP_TRI) {
        _actions.push(op);
        _attr.push(attributeData[o]);
      }
    }
    while (stack.length > 0) {
      const currId = stack.pop();
      for (let i = 0; i < 3; i++) {
        const sid = halfEdges.getSiblingTriangleIndex(currId, i);
        if (sid !== -1 && traverseSet.has(sid)) {
          stack.push(sid);
          traverseSet.delete(sid);
        }
      }
      if (_attr.length !== 0) {
        const i32 = 3 * currId;
        const i02 = aIndex.getX(i32 + 0);
        const i12 = aIndex.getX(i32 + 1);
        const i22 = aIndex.getX(i32 + 2);
        const groupIndex = groupOffset === -1 ? 0 : groupIndices[currId] + groupOffset;
        _tri2.a.fromBufferAttribute(aPosition, i02);
        _tri2.b.fromBufferAttribute(aPosition, i12);
        _tri2.c.fromBufferAttribute(aPosition, i22);
        if (!isTriDegenerate(_tri2)) {
          for (let k = 0, lk = _attr.length; k < lk; k++) {
            const action = _actions[k];
            const attrSet = _attr[k].getGroupAttrSet(groupIndex);
            const invertTri = action === INVERT_TRI;
            appendAttributesFromIndices(i02, i12, i22, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry);
          }
        }
      }
    }
  }
}

// node_modules/three-bvh-csg/src/core/Evaluator.js
function joinGroups(groups) {
  for (let i = 0; i < groups.length - 1; i++) {
    const group = groups[i];
    const nextGroup = groups[i + 1];
    if (group.materialIndex === nextGroup.materialIndex) {
      const start = group.start;
      const end = nextGroup.start + nextGroup.count;
      nextGroup.start = start;
      nextGroup.count = end - start;
      groups.splice(i, 1);
      i--;
    }
  }
}
function prepareAttributesData(referenceGeometry, targetGeometry, attributeData, relevantAttributes) {
  attributeData.clear();
  const aAttributes = referenceGeometry.attributes;
  for (let i = 0, l = relevantAttributes.length; i < l; i++) {
    const key = relevantAttributes[i];
    const aAttr = aAttributes[key];
    attributeData.initializeArray(key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized);
  }
  for (const key in attributeData.attributes) {
    if (!relevantAttributes.includes(key)) {
      attributeData.delete(key);
    }
  }
  for (const key in targetGeometry.attributes) {
    if (!relevantAttributes.includes(key)) {
      targetGeometry.deleteAttribute(key);
      targetGeometry.dispose();
    }
  }
}
function assignBufferData(geometry, attributeData, groupOrder) {
  let needsDisposal = false;
  let drawRange = -1;
  const attributes = geometry.attributes;
  const referenceAttrSet = attributeData.groupAttributes[0];
  for (const key in referenceAttrSet) {
    const requiredLength = attributeData.getTotalLength(key);
    const type = attributeData.getType(key);
    const itemSize = attributeData.getItemSize(key);
    const normalized = attributeData.getNormalized(key);
    let geoAttr = attributes[key];
    if (!geoAttr || geoAttr.array.length < requiredLength) {
      geoAttr = new BufferAttribute(new type(requiredLength), itemSize, normalized);
      geometry.setAttribute(key, geoAttr);
      needsDisposal = true;
    }
    let offset = 0;
    for (let i = 0, l = Math.min(groupOrder.length, attributeData.groupCount); i < l; i++) {
      const index = groupOrder[i].index;
      const { array, type: type2, length } = attributeData.groupAttributes[index][key];
      const trimmedArray = new type2(array.buffer, 0, length);
      geoAttr.array.set(trimmedArray, offset);
      offset += trimmedArray.length;
    }
    geoAttr.needsUpdate = true;
    drawRange = requiredLength / geoAttr.itemSize;
  }
  if (geometry.index) {
    const indexArray = geometry.index.array;
    if (indexArray.length < drawRange) {
      geometry.index = null;
      needsDisposal = true;
    } else {
      for (let i = 0, l = indexArray.length; i < l; i++) {
        indexArray[i] = i;
      }
    }
  }
  let groupOffset = 0;
  geometry.clearGroups();
  for (let i = 0, l = Math.min(groupOrder.length, attributeData.groupCount); i < l; i++) {
    const { index, materialIndex } = groupOrder[i];
    const vertCount = attributeData.getCount(index);
    if (vertCount !== 0) {
      geometry.addGroup(groupOffset, vertCount, materialIndex);
      groupOffset += vertCount;
    }
  }
  geometry.setDrawRange(0, drawRange);
  geometry.boundsTree = null;
  if (needsDisposal) {
    geometry.dispose();
  }
}
function getMaterialList(groups, materials) {
  let result = materials;
  if (!Array.isArray(materials)) {
    result = [];
    groups.forEach((g) => {
      result[g.materialIndex] = materials;
    });
  }
  return result;
}
var Evaluator = class {
  constructor() {
    this.triangleSplitter = new TriangleSplitter();
    this.attributeData = [];
    this.attributes = ["position", "uv", "normal"];
    this.useGroups = true;
    this.consolidateGroups = true;
    this.debug = new OperationDebugData();
  }
  getGroupRanges(geometry) {
    return !this.useGroups || geometry.groups.length === 0 ? [{ start: 0, count: Infinity, materialIndex: 0 }] : geometry.groups.map((group) => ({ ...group }));
  }
  evaluate(a, b, operations, targetBrushes = new Brush()) {
    let wasArray = true;
    if (!Array.isArray(operations)) {
      operations = [operations];
    }
    if (!Array.isArray(targetBrushes)) {
      targetBrushes = [targetBrushes];
      wasArray = false;
    }
    if (targetBrushes.length !== operations.length) {
      throw new Error("Evaluator: operations and target array passed as different sizes.");
    }
    a.prepareGeometry();
    b.prepareGeometry();
    const {
      triangleSplitter,
      attributeData,
      attributes,
      useGroups,
      consolidateGroups,
      debug
    } = this;
    while (attributeData.length < targetBrushes.length) {
      attributeData.push(new TypedAttributeData());
    }
    targetBrushes.forEach((brush, i) => {
      prepareAttributesData(a.geometry, brush.geometry, attributeData[i], attributes);
    });
    debug.init();
    performOperation(a, b, operations, triangleSplitter, attributeData, { useGroups });
    debug.complete();
    const aGroups = this.getGroupRanges(a.geometry);
    const aMaterials = getMaterialList(aGroups, a.material);
    const bGroups = this.getGroupRanges(b.geometry);
    const bMaterials = getMaterialList(bGroups, b.material);
    bGroups.forEach((g) => g.materialIndex += aMaterials.length);
    let groups = [...aGroups, ...bGroups].map((group, index) => ({ ...group, index }));
    if (useGroups) {
      const allMaterials = [...aMaterials, ...bMaterials];
      if (consolidateGroups) {
        groups = groups.map((group) => {
          const mat = allMaterials[group.materialIndex];
          group.materialIndex = allMaterials.indexOf(mat);
          return group;
        }).sort((a2, b2) => {
          return a2.materialIndex - b2.materialIndex;
        });
      }
      const finalMaterials = [];
      for (let i = 0, l = allMaterials.length; i < l; i++) {
        let foundGroup = false;
        for (let g = 0, lg = groups.length; g < lg; g++) {
          const group = groups[g];
          if (group.materialIndex === i) {
            foundGroup = true;
            group.materialIndex = finalMaterials.length;
          }
        }
        if (foundGroup) {
          finalMaterials.push(allMaterials[i]);
        }
      }
      targetBrushes.forEach((tb) => {
        tb.material = finalMaterials;
      });
    } else {
      groups = [{ start: 0, count: Infinity, index: 0, materialIndex: 0 }];
      targetBrushes.forEach((tb) => {
        tb.material = aMaterials[0];
      });
    }
    targetBrushes.forEach((brush, i) => {
      const targetGeometry = brush.geometry;
      assignBufferData(targetGeometry, attributeData[i], groups);
      if (consolidateGroups) {
        joinGroups(targetGeometry.groups);
      }
    });
    return wasArray ? targetBrushes : targetBrushes[0];
  }
  // TODO: fix
  evaluateHierarchy(root, target = new Brush()) {
    root.updateMatrixWorld(true);
    const flatTraverse = (obj, cb) => {
      const children = obj.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        if (child.isOperationGroup) {
          flatTraverse(child, cb);
        } else {
          cb(child);
        }
      }
    };
    const traverse = (brush) => {
      const children = brush.children;
      let didChange = false;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        didChange = traverse(child) || didChange;
      }
      const isDirty = brush.isDirty();
      if (isDirty) {
        brush.markUpdated();
      }
      if (didChange && !brush.isOperationGroup) {
        let result;
        flatTraverse(brush, (child) => {
          if (!result) {
            result = this.evaluate(brush, child, child.operation);
          } else {
            result = this.evaluate(result, child, child.operation);
          }
        });
        brush._cachedGeometry = result.geometry;
        brush._cachedMaterials = result.material;
        return true;
      } else {
        return didChange || isDirty;
      }
    };
    traverse(root);
    target.geometry = root._cachedGeometry;
    target.material = root._cachedMaterials;
    return target;
  }
  reset() {
    this.triangleSplitter.reset();
  }
};

// node_modules/three-bvh-csg/src/core/operations/Operation.js
var Operation = class extends Brush {
  constructor(...args) {
    super(...args);
    this.isOperation = true;
    this.operation = ADDITION;
    this._cachedGeometry = new BufferGeometry();
    this._cachedMaterials = null;
    this._previousOperation = null;
  }
  markUpdated() {
    super.markUpdated();
    this._previousOperation = this.operation;
  }
  isDirty() {
    return this.operation !== this._previousOperation || super.isDirty();
  }
  insertBefore(brush) {
    const parent = this.parent;
    const index = parent.children.indexOf(this);
    parent.children.splice(index, 0, brush);
  }
  insertAfter(brush) {
    const parent = this.parent;
    const index = parent.children.indexOf(this);
    parent.children.splice(index + 1, 0, brush);
  }
};

// node_modules/three-bvh-csg/src/core/operations/OperationGroup.js
var OperationGroup = class extends Group {
  constructor() {
    super();
    this.isOperationGroup = true;
    this._previousMatrix = new Matrix4();
  }
  markUpdated() {
    this._previousMatrix.copy(this.matrix);
  }
  isDirty() {
    const { matrix, _previousMatrix } = this;
    const el1 = matrix.elements;
    const el2 = _previousMatrix.elements;
    for (let i = 0; i < 16; i++) {
      if (el1[i] !== el2[i]) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/three-bvh-csg/src/materials/shaderUtils.js
function addWorldPosition(shader) {
  if (/varying\s+vec3\s+wPosition/.test(shader.vertexShader)) return;
  shader.vertexShader = `
			varying vec3 wPosition;
			${shader.vertexShader}
		`.replace(
    /#include <displacementmap_vertex>/,
    (v) => `${v}
				wPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;
				`
  );
  shader.fragmentShader = `
		varying vec3 wPosition;
		${shader.fragmentShader}
		`;
  return shader;
}
function csgGridShaderMixin(shader) {
  shader.uniforms = {
    ...shader.uniforms,
    checkerboardColor: { value: new Color(1118481) }
  };
  addWorldPosition(shader);
  shader.defines = { CSG_GRID: 1 };
  shader.fragmentShader = shader.fragmentShader.replace(
    /#include <common>/,
    (v) => (
      /* glsl */
      `
			${v}

			uniform vec3 checkerboardColor;
			float getCheckerboard( vec2 p, float scale ) {

				p /= scale;
				p += vec2( 0.5 );

				vec2 line = mod( p, 2.0 ) - vec2( 1.0 );
				line = abs( line );

				vec2 pWidth = fwidth( line );
				vec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );
				float result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );

				return result;

			}

			float getGrid( vec2 p, float scale, float thickness ) {

				p /= 0.5 * scale;

				vec2 stride = mod( p, 2.0 ) - vec2( 1.0 );
				stride = abs( stride );

				vec2 pWidth = fwidth( p );
				vec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );

				return max( line.x, line.y );

			}

			vec3 getFaceColor( vec2 p, vec3 color ) {

				float checkLarge = getCheckerboard( p, 1.0 );
				float checkSmall = abs( getCheckerboard( p, 0.1 ) );
				float lines = getGrid( p, 10.0, 1.0 );

				vec3 checkColor = mix(
					vec3( 0.7 ) * color,
					vec3( 1.0 ) * color,
					checkSmall * 0.4 + checkLarge * 0.6
				);

				vec3 gridColor = vec3( 1.0 );

				return mix( checkColor, gridColor, lines );

			}

			float angleBetween( vec3 a, vec3 b ) {

				return acos( abs( dot( a, b ) ) );

			}

			vec3 planeProject( vec3 norm, vec3 other ) {

				float d = dot( norm, other );
				return normalize( other - norm * d );

			}

			vec3 getBlendFactors( vec3 norm ) {

				vec3 xVec = vec3( 1.0, 0.0, 0.0 );
				vec3 yVec = vec3( 0.0, 1.0, 0.0 );
				vec3 zVec = vec3( 0.0, 0.0, 1.0 );

				vec3 projX = planeProject( xVec, norm );
				vec3 projY = planeProject( yVec, norm );
				vec3 projZ = planeProject( zVec, norm );

				float xAngle = max(
					angleBetween( xVec, projY ),
					angleBetween( xVec, projZ )
				);

				float yAngle = max(
					angleBetween( yVec, projX ),
					angleBetween( yVec, projZ )
				);

				float zAngle = max(
					angleBetween( zVec, projX ),
					angleBetween( zVec, projY )
				);

				return vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );

			}
		`
    )
  ).replace(
    /#include <normal_fragment_maps>/,
    (v) => (
      /* glsl */
      `${v}
				#if CSG_GRID
				{

					vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

					float yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );
					float zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );
					float xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );

					vec3 factors = getBlendFactors( worldNormal );
					factors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );

					float weight = factors.x + factors.y + factors.z;
					factors /= weight;

					vec3 color =
						getFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +
						getFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +
						getFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;

					diffuseColor.rgb = color;

				}
				#endif
				`
    )
  );
  return shader;
}

// node_modules/three-bvh-csg/src/materials/GridMaterial.js
var GridMaterial = class extends MeshPhongMaterial {
  get enableGrid() {
    return Boolean(this._enableGrid);
  }
  set enableGrid(v) {
    if (this._enableGrid !== v) {
      this._enableGrid = v;
      this.needsUpdate = true;
    }
  }
  constructor(...args) {
    super(...args);
    this.enableGrid = true;
  }
  onBeforeCompile(shader) {
    csgGridShaderMixin(shader);
    shader.defines.CSG_GRID = Number(this.enableGrid);
  }
  customProgramCacheKey() {
    return this.enableGrid.toString();
  }
};

// node_modules/three-bvh-csg/src/core/debug/debugUtils.js
function getTriangleDefinitions(...triangles) {
  function getVectorDefinition(v) {
    return (
      /* js */
      `new THREE.Vector3( ${v.x}, ${v.y}, ${v.z} )`
    );
  }
  return triangles.map((t) => {
    return (
      /* js */
      `
new THREE.Triangle(
	${getVectorDefinition(t.a)},
	${getVectorDefinition(t.b)},
	${getVectorDefinition(t.c)},
)
		`.trim()
    );
  });
}
function logTriangleDefinitions(...triangles) {
  console.log(getTriangleDefinitions(...triangles).join(",\n"));
}
function generateRandomTriangleColors(geometry) {
  const position = geometry.attributes.position;
  const array = new Float32Array(position.count * 3);
  const color = new Color();
  for (let i = 0, l = array.length; i < l; i += 9) {
    color.setHSL(
      Math.random(),
      MathUtils.lerp(0.5, 1, Math.random()),
      MathUtils.lerp(0.5, 0.75, Math.random())
    );
    array[i + 0] = color.r;
    array[i + 1] = color.g;
    array[i + 2] = color.b;
    array[i + 3] = color.r;
    array[i + 4] = color.g;
    array[i + 5] = color.b;
    array[i + 6] = color.r;
    array[i + 7] = color.g;
    array[i + 8] = color.b;
  }
  geometry.setAttribute("color", new BufferAttribute(array, 3));
}

// node_modules/three-bvh-csg/src/objects/TriangleSetHelper.js
var TriangleSetHelper = class extends Group {
  get color() {
    return this._mesh.material.color;
  }
  get side() {
    return this._mesh.material.side;
  }
  set side(v) {
    this._mesh.material.side = v;
  }
  constructor(triangles = []) {
    super();
    const geometry = new BufferGeometry();
    const lineGeom = new BufferGeometry();
    this._mesh = new Mesh(geometry, new MeshPhongMaterial({
      flatShading: true,
      transparent: true,
      opacity: 0.25,
      depthWrite: false
    }));
    this._lines = new LineSegments(lineGeom, new LineBasicMaterial());
    this._mesh.material.color = this._lines.material.color;
    this._lines.frustumCulled = false;
    this._mesh.frustumCulled = false;
    this.add(this._lines, this._mesh);
    this.setTriangles(triangles);
  }
  setTriangles(triangles) {
    const triPositions = new Float32Array(3 * 3 * triangles.length);
    const linePositions = new Float32Array(6 * 3 * triangles.length);
    for (let i = 0, l = triangles.length; i < l; i++) {
      const i9 = 9 * i;
      const i18 = 18 * i;
      const tri = triangles[i];
      tri.a.toArray(triPositions, i9 + 0);
      tri.b.toArray(triPositions, i9 + 3);
      tri.c.toArray(triPositions, i9 + 6);
      tri.a.toArray(linePositions, i18 + 0);
      tri.b.toArray(linePositions, i18 + 3);
      tri.b.toArray(linePositions, i18 + 6);
      tri.c.toArray(linePositions, i18 + 9);
      tri.c.toArray(linePositions, i18 + 12);
      tri.a.toArray(linePositions, i18 + 15);
    }
    this._mesh.geometry.dispose();
    this._mesh.geometry.setAttribute("position", new BufferAttribute(triPositions, 3));
    this._lines.geometry.dispose();
    this._lines.geometry.setAttribute("position", new BufferAttribute(linePositions, 3));
  }
};

// node_modules/three-bvh-csg/src/objects/EdgesHelper.js
var EdgesHelper = class extends LineSegments {
  get color() {
    return this.material.color;
  }
  constructor(edges = []) {
    super();
    this.frustumCulled = false;
    this.setEdges(edges);
  }
  setEdges(edges) {
    const { geometry } = this;
    const points = edges.flatMap((e) => [e.start, e.end]);
    geometry.dispose();
    geometry.setFromPoints(points);
  }
};

// node_modules/three-bvh-csg/src/objects/PointsHelper.js
var _matrix3 = new Matrix4();
var PointsHelper = class extends InstancedMesh {
  get color() {
    return this.material.color;
  }
  constructor(count = 1e3, points = []) {
    super(new SphereGeometry(0.025), new MeshBasicMaterial(), count);
    this.frustumCulled = false;
    this.setPoints(points);
  }
  setPoints(points) {
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      _matrix3.makeTranslation(point.x, point.y, point.z);
      this.setMatrixAt(i, _matrix3);
    }
    this.count = points.length;
  }
};

// node_modules/three-bvh-csg/src/objects/HalfEdgeHelper.js
var vertKeys = ["a", "b", "c"];
var _tri1 = new Triangle();
var _tri22 = new Triangle();
var _center = new Vector3();
var _center2 = new Vector3();
var _projected = new Vector3();
var _projected2 = new Vector3();
var _projectedDir = new Vector3();
var _projectedDir2 = new Vector3();
var _edgeDir = new Vector3();
var _edgeDir2 = new Vector3();
var _vec5 = new Vector3();
var _vec22 = new Vector3();
var _finalPoint = new Vector3();
var _finalPoint2 = new Vector3();
var _plane2 = new Plane();
var _plane22 = new Plane();
var _centerPoint = new Vector3();
var _ray3 = new Ray();
var _edge3 = new Line3();
function getTriangle(geometry, triIndex, target) {
  const i3 = 3 * triIndex;
  let i0 = i3 + 0;
  let i1 = i3 + 1;
  let i2 = i3 + 2;
  const indexAttr = geometry.index;
  const posAttr = geometry.attributes.position;
  if (indexAttr) {
    i0 = indexAttr.getX(i0);
    i1 = indexAttr.getX(i1);
    i2 = indexAttr.getX(i2);
  }
  target.a.fromBufferAttribute(posAttr, i0);
  target.b.fromBufferAttribute(posAttr, i1);
  target.c.fromBufferAttribute(posAttr, i2);
  return target;
}
function getOverlapEdge(tri1, e1, tri2, e2, target) {
  const nextE_0 = (e1 + 1) % 3;
  const v0_1 = tri1[vertKeys[e1]];
  const v1_1 = tri1[vertKeys[nextE_0]];
  const nextE_1 = (e2 + 1) % 3;
  const v0_2 = tri2[vertKeys[e2]];
  const v1_2 = tri2[vertKeys[nextE_1]];
  toNormalizedRay(v0_1, v1_1, _ray3);
  let d0_1 = _vec5.subVectors(v0_1, _ray3.origin).dot(_ray3.direction);
  let d1_1 = _vec5.subVectors(v1_1, _ray3.origin).dot(_ray3.direction);
  if (d0_1 > d1_1) [d0_1, d1_1] = [d1_1, d0_1];
  let d0_2 = _vec5.subVectors(v0_2, _ray3.origin).dot(_ray3.direction);
  let d1_2 = _vec5.subVectors(v1_2, _ray3.origin).dot(_ray3.direction);
  if (d0_2 > d1_2) [d0_2, d1_2] = [d1_2, d0_2];
  const final_0 = Math.max(d0_1, d0_2);
  const final_1 = Math.min(d1_1, d1_2);
  _ray3.at(final_0, target.start);
  _ray3.at(final_1, target.end);
}
var HalfEdgeHelper = class extends EdgesHelper {
  constructor(geometry = null, halfEdges = null) {
    super();
    this.straightEdges = false;
    this.displayDisconnectedEdges = false;
    if (geometry && halfEdges) {
      this.setHalfEdges(geometry, halfEdges);
    }
  }
  setHalfEdges(geometry, halfEdges) {
    const { straightEdges, displayDisconnectedEdges } = this;
    const edges = [];
    const offset = geometry.drawRange.start;
    let triCount = getTriCount(geometry);
    if (geometry.drawRange.count !== Infinity) {
      triCount = ~~(geometry.drawRange.count / 3);
    }
    if (displayDisconnectedEdges) {
      if (halfEdges.unmatchedDisjointEdges) {
        halfEdges.unmatchedDisjointEdges.forEach(({ forward, reverse, ray }) => {
          [...forward, ...reverse].forEach(({ start, end }) => {
            const edge = new Line3();
            ray.at(start, edge.start);
            ray.at(end, edge.end);
            edges.push(edge);
          });
        });
      } else {
        for (let triIndex = offset; triIndex < triCount; triIndex++) {
          getTriangle(geometry, triIndex, _tri1);
          for (let e = 0; e < 3; e++) {
            const otherTriIndex = halfEdges.getSiblingTriangleIndex(triIndex, e);
            if (otherTriIndex === -1) {
              const nextE = (e + 1) % 3;
              const v0 = _tri1[vertKeys[e]];
              const v1 = _tri1[vertKeys[nextE]];
              const edge = new Line3();
              edge.start.copy(v0);
              edge.end.copy(v1);
              edges.push(edge);
            }
          }
        }
      }
    } else {
      for (let triIndex = offset; triIndex < triCount; triIndex++) {
        getTriangle(geometry, triIndex, _tri1);
        for (let e = 0; e < 3; e++) {
          const otherTriIndex = halfEdges.getSiblingTriangleIndex(triIndex, e);
          if (otherTriIndex === -1) {
            continue;
          }
          getTriangle(geometry, otherTriIndex, _tri22);
          const nextE = (e + 1) % 3;
          const v0 = _tri1[vertKeys[e]];
          const v1 = _tri1[vertKeys[nextE]];
          _centerPoint.lerpVectors(v0, v1, 0.5);
          addConnectionEdge(_tri1, _tri22, _centerPoint);
        }
        if (halfEdges.disjointConnections) {
          for (let e = 0; e < 3; e++) {
            const disjointTriIndices = halfEdges.getDisjointSiblingTriangleIndices(triIndex, e);
            const disjointEdgeIndices = halfEdges.getDisjointSiblingEdgeIndices(triIndex, e);
            for (let i = 0; i < disjointTriIndices.length; i++) {
              const ti = disjointTriIndices[i];
              const ei = disjointEdgeIndices[i];
              getTriangle(geometry, ti, _tri22);
              getOverlapEdge(_tri1, e, _tri22, ei, _edge3);
              _centerPoint.lerpVectors(_edge3.start, _edge3.end, 0.5);
              addConnectionEdge(_tri1, _tri22, _centerPoint);
            }
          }
        }
      }
    }
    super.setEdges(edges);
    function addConnectionEdge(tri1, tri2, centerPoint) {
      tri1.getMidpoint(_center);
      tri2.getMidpoint(_center2);
      tri1.getPlane(_plane2);
      tri2.getPlane(_plane22);
      const edge = new Line3();
      edge.start.copy(_center);
      if (straightEdges) {
        _plane2.projectPoint(_center2, _projected);
        _plane22.projectPoint(_center, _projected2);
        _projectedDir.subVectors(_projected, _center);
        _projectedDir2.subVectors(_projected2, _center2);
        _edgeDir.subVectors(centerPoint, _center);
        _edgeDir2.subVectors(centerPoint, _center2);
        if (_projectedDir.dot(_edgeDir) < 0) {
          _projectedDir.multiplyScalar(-1);
        }
        if (_projectedDir2.dot(_edgeDir2) < 0) {
          _projectedDir2.multiplyScalar(-1);
        }
        _vec5.addVectors(_center, _projectedDir);
        _vec22.addVectors(_center2, _projectedDir2);
        tri1.closestPointToPoint(_vec5, _finalPoint);
        tri2.closestPointToPoint(_vec22, _finalPoint2);
        edge.end.lerpVectors(_finalPoint, _finalPoint2, 0.5);
      } else {
        edge.end.copy(centerPoint);
      }
      edges.push(edge);
    }
  }
};

// node_modules/three-bvh-csg/src/utils/computeMeshVolume.js
var _tri3 = new Triangle();
var _normal2 = new Vector3();
var _relPoint = new Vector3();
function computeMeshVolume(mesh) {
  let geometry;
  let matrix;
  if (mesh.isBufferGeometry) {
    geometry = mesh;
    matrix = null;
  } else {
    geometry = mesh.geometry;
    matrix = Math.abs(mesh.matrixWorld.determinant() - 1) < 1e-15 ? null : mesh.matrixWorld;
  }
  const index = geometry.index;
  const pos = geometry.attributes.position;
  const drawRange = geometry.drawRange;
  const triCount = Math.min(getTriCount(geometry), drawRange.count / 3);
  _tri3.setFromAttributeAndIndices(pos, 0, 1, 2);
  applyMatrix4ToTri(_tri3, matrix);
  _tri3.getNormal(_normal2);
  _tri3.getMidpoint(_relPoint).add(_normal2);
  let volume = 0;
  const startIndex = drawRange.start / 3;
  for (let i = startIndex, l = startIndex + triCount; i < l; i++) {
    let i0 = 3 * i + 0;
    let i1 = 3 * i + 1;
    let i2 = 3 * i + 2;
    if (index) {
      i0 = index.getX(i0);
      i1 = index.getX(i1);
      i2 = index.getX(i2);
    }
    _tri3.setFromAttributeAndIndices(pos, i0, i1, i2);
    applyMatrix4ToTri(_tri3, matrix);
    subVectorFromTri(_tri3, _relPoint);
    volume += signedVolumeOfTriangle(_tri3.a, _tri3.b, _tri3.c);
  }
  return Math.abs(volume);
}
function signedVolumeOfTriangle(p1, p2, p3) {
  const v321 = p3.x * p2.y * p1.z;
  const v231 = p2.x * p3.y * p1.z;
  const v312 = p3.x * p1.y * p2.z;
  const v132 = p1.x * p3.y * p2.z;
  const v213 = p2.x * p1.y * p3.z;
  const v123 = p1.x * p2.y * p3.z;
  return 1 / 6 * (-v321 + v231 + v312 - v132 - v213 + v123);
}
function subVectorFromTri(tri, pos) {
  tri.a.sub(pos);
  tri.b.sub(pos);
  tri.c.sub(pos);
}
function applyMatrix4ToTri(tri, mat = null) {
  if (mat !== null) {
    tri.a.applyMatrix4(mat);
    tri.b.applyMatrix4(mat);
    tri.c.applyMatrix4(mat);
  }
}
export {
  ADDITION,
  Brush,
  DIFFERENCE,
  EdgesHelper,
  Evaluator,
  GridMaterial,
  HOLLOW_INTERSECTION,
  HOLLOW_SUBTRACTION,
  HalfEdgeHelper,
  HalfEdgeMap,
  INTERSECTION,
  Operation,
  OperationGroup,
  PointsHelper,
  REVERSE_SUBTRACTION,
  SUBTRACTION,
  TriangleSetHelper,
  TriangleSplitter,
  computeMeshVolume,
  generateRandomTriangleColors,
  getTriangleDefinitions,
  logTriangleDefinitions
};
//# sourceMappingURL=three-bvh-csg.js.map
